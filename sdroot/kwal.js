/*
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  DO NOT EDIT THIS FILE - COPILOT MEANS YOU                    â•‘
 * â•‘  Source: sdroot/webgui-src/js/*.js                            â•‘
 * â•‘  Build:  cd webgui-src; .\build.ps1                           â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Kwal WebGUI v260213A - Built 2026-02-15 08:49
 */

// === js/namespace.js ===
/*
 * Kwal - Global namespace
 */
var Kwal = Kwal || {};
window.KWAL_JS_VERSION = '260213A';  // Injected by build.ps1

/**
 * Logarithmic slider mapping (power curve).
 * Gives fine control at the low end, coarser at the high end.
 * Exponent 2 (quadratic) â€” perceptually natural for brightness, volume, speed.
 *
 * sliderToValue(pos, min, max) â€” slider position â†’ real value
 * valueToSlider(val, min, max) â€” real value â†’ slider position (for SSE updates)
 */
Kwal.LOG_EXP = 2;

Kwal.sliderToValue = function(pos, min, max) {
  var fraction = (pos - min) / (max - min);       // 0..1
  var curved = Math.pow(fraction, Kwal.LOG_EXP);   // apply curve
  return min + curved * (max - min);
};

Kwal.valueToSlider = function(val, min, max) {
  var fraction = (val - min) / (max - min);         // 0..1
  var linear = Math.pow(fraction, 1 / Kwal.LOG_EXP); // invert curve
  return min + linear * (max - min);
};


// === js/state.js ===
/*
 * Kwal - State module
 * Tracks modified state for colors and patterns
 */
Kwal.state = (function() {
  'use strict';

  var colorsModified = false;
  var patternModified = false;
  
  // Original values to revert to
  var originalColors = { a: null, b: null, id: null };
  var originalPattern = { id: null };

  function setColorsModified(modified, colorA, colorB, id) {
    colorsModified = modified;
    if (modified && colorA && colorB) {
      originalColors = { a: colorA, b: colorB, id: id };
    }
    updateDevModal();
  }

  function setPatternModified(modified, id) {
    patternModified = modified;
    if (modified && id) {
      originalPattern = { id: id };
    }
    updateDevModal();
  }

  function isColorsModified() { return colorsModified; }
  function isPatternModified() { return patternModified; }
  function getOriginalColors() { return originalColors; }
  function getOriginalPattern() { return originalPattern; }

  function clearColorsModified() {
    colorsModified = false;
    originalColors = { a: null, b: null, id: null };
    updateDevModal();
  }

  function clearPatternModified() {
    patternModified = false;
    originalPattern = { id: null };
    updateDevModal();
  }

  function updateDevModal() {
    var saveColorsBtn = document.getElementById('save-colors-btn');
    var savePatternBtn = document.getElementById('save-pattern-btn');
    if (saveColorsBtn) {
      saveColorsBtn.style.display = colorsModified ? 'block' : 'none';
    }
    if (savePatternBtn) {
      savePatternBtn.style.display = patternModified ? 'block' : 'none';
    }
  }

  return {
    setColorsModified: setColorsModified,
    setPatternModified: setPatternModified,
    isColorsModified: isColorsModified,
    isPatternModified: isPatternModified,
    getOriginalColors: getOriginalColors,
    getOriginalPattern: getOriginalPattern,
    clearColorsModified: clearColorsModified,
    clearPatternModified: clearPatternModified
  };
})();


// === js/audio.js ===
/*
 * Kwal - Audio module
 * See docs/glossary_slider_semantics.md for terminology
 * 
 * Slider moves freely 0-100%. Grey zones show shiftedLo/Hi
 * as visual indicators but do NOT restrict the thumb.
 * 
 * sliderPct = current volume as percentage of Lo..Hi range
 */
Kwal.audio = (function() {
  'use strict';

  var slider, label, nextBtn, dirEl, fileEl, boxLabelEl;
  var voteUpBtn, voteDownBtn, voteScoreEl;
  var currentDir = null, currentFile = null;
  var isPlaying = false;
  var playingTimeout = null;
  var pctMin = 0;     // Slider minimum
  var pctMax = 100;   // Slider maximum
  var loPct = 0;      // Grey zone left boundary (visual only)
  var hiPct = 100;    // Grey zone right boundary (visual only)

  function updateGradient() {
    if (!slider) return;
    var style = 'linear-gradient(to right, ' +
      '#555 0%, #555 ' + loPct + '%, ' +
      '#4682B4 ' + loPct + '%, #4682B4 ' + hiPct + '%, ' +
      '#555 ' + hiPct + '%, #555 100%)';
    slider.style.background = style;
  }

  function setPlayingState(playing) {
    isPlaying = playing;
    if (dirEl) dirEl.classList.toggle('disabled', playing);
    if (fileEl) fileEl.classList.toggle('disabled', playing);
  }

  function init() {
    slider = document.getElementById('volume');
    label = document.getElementById('vol-num');
    nextBtn = document.getElementById('audio-next');
    dirEl = document.getElementById('audio-dir');
    fileEl = document.getElementById('audio-file');
    boxLabelEl = document.getElementById('audio-box-label');
    voteUpBtn = document.getElementById('vote-up');
    voteDownBtn = document.getElementById('vote-down');
    voteScoreEl = document.getElementById('vote-score');
    
    if (slider && label) {
      slider.oninput = function() {
        var pos = Math.max(pctMin, Math.min(pctMax, parseInt(slider.value, 10)));
        slider.value = pos;
        label.textContent = pos + '%';
      };

      slider.onchange = function() {
        var pos = Math.max(pctMin, Math.min(pctMax, parseInt(slider.value, 10)));
        slider.value = pos;
        label.textContent = pos + '%';
        // Send linear value - firmware calculates webMultiplier
        fetch('/setWebAudioLevel?value=' + pos, { method: 'POST' }).catch(function() {});
      };
      
      updateGradient();
    }

    if (nextBtn) {
      nextBtn.onclick = function() {
        nextBtn.disabled = true;
        fetch('/api/audio/next', { method: 'POST' })
          .then(function() {
            setTimeout(function() {
              nextBtn.disabled = false;
            }, 500);
          })
          .catch(function() {
            nextBtn.disabled = false;
          });
      };
    }

    // Click dir: play random from same dir
    if (dirEl) {
      dirEl.onclick = function() {
        if (currentDir !== null && !isPlaying) {
          setPlayingState(true);
          if (playingTimeout) clearTimeout(playingTimeout);
          playingTimeout = setTimeout(function() { setPlayingState(false); }, 32000);
          fetch('/api/audio/play?dir=' + currentDir).catch(function() {
            setPlayingState(false);
          });
        }
      };
    }

    // Click file: replay exact fragment
    if (fileEl) {
      fileEl.onclick = function() {
        if (currentDir !== null && currentFile !== null && !isPlaying) {
          setPlayingState(true);
          if (playingTimeout) clearTimeout(playingTimeout);
          playingTimeout = setTimeout(function() { setPlayingState(false); }, 32000);
          fetch('/api/audio/play?dir=' + currentDir + '&file=' + currentFile).catch(function() {
            setPlayingState(false);
          });
        }
      };
    }

    if (voteUpBtn) {
      voteUpBtn.onclick = function() { vote(3); };
    }
    if (voteDownBtn) {
      voteDownBtn.onclick = function() { vote(-5); };
    }
    
    // No load() - initial state comes from SSE
  }

  function vote(delta) {
    // Optimistic UI - update score immediately, fire-and-forget
    if (voteScoreEl) {
      var current = parseInt(voteScoreEl.textContent, 10);
      if (!isNaN(current)) {
        var newScore = Math.max(1, Math.min(200, current + delta));
        voteScoreEl.textContent = String(newScore);
      }
    }
    // Fire and forget - no blocking
    fetch('/vote?delta=' + delta, { method: 'POST' }).catch(function() {});
  }

  /**
   * Update volume slider from SSE state event
   * @param {number} sliderPct Current volume as percentage (0-100)
   * @param {number} loPercent Left grey zone boundary (%)
   * @param {number} hiPercent Right grey zone boundary (%)
   */
  function updateVolumeFromState(sliderPct, loPercent, hiPercent) {
    if (typeof loPercent === 'number') loPct = loPercent;
    if (typeof hiPercent === 'number') hiPct = hiPercent;
    updateGradient();
    if (slider && label && typeof sliderPct === 'number') {
      var pos = Math.max(pctMin, Math.min(pctMax, Math.round(sliderPct)));
      slider.value = pos;
      label.textContent = pos + '%';
    }
  }

  /**
   * Update fragment display from SSE event
   * @param {number} dir 
   * @param {number} file 
   * @param {number} score
   * @param {number} durationMs Fragment duration in ms (0 = use default)
   */
  function updateFragment(dir, file, score, durationMs, boxName) {
    var isFirstLoad = (currentDir === null);
    var isNewFragment = (dir !== currentDir || file !== currentFile);
    currentDir = dir;
    currentFile = file;
    
    // Only set playing state if this is a NEW fragment during runtime (not first SSE connect)
    if (!isFirstLoad && isNewFragment && dir > 0 && file > 0) {
      setPlayingState(true);
      if (playingTimeout) clearTimeout(playingTimeout);
      // Use durationMs from SSE, fallback to 32s if not available
      var timeout = (typeof durationMs === 'number' && durationMs > 0) ? durationMs + 200 : 32000;
      playingTimeout = setTimeout(function() { setPlayingState(false); }, timeout);
    }
    
    if (dirEl) {
      dirEl.textContent = String(dir).padStart(3, '0');
    }
    if (fileEl) {
      fileEl.textContent = String(file).padStart(3, '0');
    }
    if (typeof score === 'number' && voteScoreEl) {
      voteScoreEl.textContent = score;
    }
    if (boxLabelEl && typeof boxName === 'string' && boxName.length > 0) {
      boxLabelEl.textContent = boxName;
    }
  }

  return { init: init, updateVolumeFromState: updateVolumeFromState, updateFragment: updateFragment };
})();


// === js/brightness.js ===
/*
 * Kwal - Brightness module
 * See docs/glossary_slider_semantics.md for terminology
 * 
 * Slider moves freely 0-100%. Grey zones show shiftedLo/Hi
 * as visual indicators but do NOT restrict the thumb.
 * 
 * sliderPct = current brightness as percentage of Lo..Hi range
 */
Kwal.brightness = (function() {
  'use strict';

  var slider, label;
  var pctMin = 0;     // Slider minimum
  var pctMax = 100;   // Slider maximum
  var loPct = 28;     // Grey zone left boundary (visual only)
  var hiPct = 100;    // Grey zone right boundary (visual only)

  function updateGradient() {
    if (!slider) return;
    // Grey | Green | Grey
    var style = 'linear-gradient(to right, ' +
      '#555 0%, #555 ' + loPct + '%, ' +
      '#4CAF50 ' + loPct + '%, #4CAF50 ' + hiPct + '%, ' +
      '#555 ' + hiPct + '%, #555 100%)';
    slider.style.background = style;
  }

  function init() {
    slider = document.getElementById('brightness');
    label = document.getElementById('bri-num');
    
    if (!slider || !label) return;

    slider.oninput = function() {
      var pos = Math.max(pctMin, Math.min(pctMax, parseInt(slider.value, 10)));
      slider.value = pos;
      label.textContent = pos + '%';
    };

    slider.onchange = function() {
      var pos = Math.max(pctMin, Math.min(pctMax, parseInt(slider.value, 10)));
      slider.value = pos;
      label.textContent = pos + '%';
      fetch('/setBrightness?value=' + pos, { method: 'POST' }).catch(function() {});
    };
    
    updateGradient();
  }

  /**
   * Update brightness from SSE state event
   * @param {number} sliderPct Current brightness as percentage (0-100)
   * @param {number} loPercent Left grey zone boundary (%)
   * @param {number} hiPercent Right grey zone boundary (%)
   */
  function updateFromState(sliderPct, loPercent, hiPercent) {
    if (typeof loPercent === 'number') loPct = loPercent;
    if (typeof hiPercent === 'number') hiPct = hiPercent;
    updateGradient();
    if (slider && label && typeof sliderPct === 'number') {
      var pos = Math.max(pctMin, Math.min(pctMax, Math.round(sliderPct)));
      slider.value = pos;
      label.textContent = pos + '%';
    }
  }

  return { init: init, updateFromState: updateFromState };
})();


// === js/modal.js ===
/*
 * Kwal - Modal module
 */
Kwal.modal = (function() {
  'use strict';

  var backdropLocked = false;

  function init() {
    // Dev button opens dev modal
    var devBtn = document.getElementById('dev-btn');
    if (devBtn) {
      devBtn.onclick = function() { open('dev-modal'); };
    }

    // Buttons with data-open attribute
    var openBtns = document.querySelectorAll('[data-open]');
    for (var i = 0; i < openBtns.length; i++) {
      (function(btn) {
        btn.onclick = function() {
          close('dev-modal');
          var targetId = btn.getAttribute('data-open');
          open(targetId);
          // Trigger load for specific modals
          if (targetId === 'pattern-modal') Kwal.pattern.load();
          if (targetId === 'colors-modal') Kwal.colors.load();
        };
      })(openBtns[i]);
    }

    // Buttons with data-close attribute
    var closeBtns = document.querySelectorAll('[data-close]');
    for (var j = 0; j < closeBtns.length; j++) {
      (function(btn) {
        btn.onclick = function() {
          var modal = btn.closest('.modal');
          if (modal) modal.classList.remove('open');
          // Return to parent modal if specified
          var returnTo = btn.getAttribute('data-return');
          if (returnTo) open(returnTo);
        };
      })(closeBtns[j]);
    }

    // Click on backdrop closes modal (unless locked)
    var modals = document.querySelectorAll('.modal');
    for (var k = 0; k < modals.length; k++) {
      (function(m) {
        m.onclick = function(e) {
          if (e.target === m && !backdropLocked) m.classList.remove('open');
        };
      })(modals[k]);
    }
  }

  function open(id) {
    var el = document.getElementById(id);
    if (el) el.classList.add('open');
  }

  function close(id) {
    var el = document.getElementById(id);
    if (el) el.classList.remove('open');
  }

  function lockBackdrop() { backdropLocked = true; }
  function unlockBackdrop() { backdropLocked = false; }

  return { init: init, open: open, close: close, lockBackdrop: lockBackdrop, unlockBackdrop: unlockBackdrop };
})();


// === js/sd.js ===
/*
 * Kwal - SD module (simple upload to root)
 */
Kwal.sd = (function() {
  'use strict';

  var fileInput, uploadBtn, uploadMsg;

  function init() {
    fileInput = document.getElementById('upload-file');
    uploadBtn = document.getElementById('upload-btn');
    uploadMsg = document.getElementById('upload-msg');

    if (uploadBtn) uploadBtn.onclick = upload;
  }

  function upload() {
    if (!fileInput || !fileInput.files[0]) {
      showMsg('No file selected', true);
      return;
    }

    var file = fileInput.files[0];
    showMsg('Uploading...', false);

    var form = new FormData();
    form.append('file', file);

    fetch('/api/sd/upload', { method: 'POST', body: form })
      .then(function(r) {
        if (!r.ok) throw new Error(r.statusText);
        return r.json();
      })
      .then(function(data) {
        showMsg('OK: ' + (data.path || file.name), false);
        fileInput.value = '';
      })
      .catch(function(err) {
        showMsg('Error: ' + err.message, true);
      });
  }

  function showMsg(text, isError) {
    if (uploadMsg) {
      uploadMsg.textContent = text;
      uploadMsg.className = isError ? 'err' : 'ok';
    }
  }

  return {
    init: init
  };
})();


// === js/pattern.js ===
/*
 * Kwal - Pattern module
 * API: GET /api/patterns, POST /api/patterns/select, POST /api/patterns/preview
 */
Kwal.pattern = (function() {
  'use strict';

  var listEl, activeId, patternsData = [];
  var editingId = null;
  var originalLabel = null;
  var currentParams = null;
  var previewTimeout = null;
  var expandedId = null;

  // Parameter definitions with limits from old code
  var PARAMS = [
    { key: 'color_cycle_sec',  label: 'Color Cycle (s)',  min: 1,    max: 120, step: 1 },
    { key: 'bright_cycle_sec', label: 'Bright Cycle (s)', min: 1,    max: 120, step: 1 },
    { key: 'min_brightness',   label: 'Min Brightness',   min: 1,    max: 255, step: 1 },
    { key: 'fade_width',       label: 'Fade Width',       min: 1,    max: 400, step: 0.5 },
    { key: 'gradient_speed',   label: 'Gradient Speed',   min: 0.01, max: 1,   step: 0.01 },
    { key: 'center_x',         label: 'Center X',         min: -132, max: 132, step: 0.5 },
    { key: 'center_y',         label: 'Center Y',         min: -132, max: 132, step: 0.5 },
    { key: 'radius',           label: 'Radius',           min: 1,    max: 164, step: 0.5 },
    { key: 'window_width',     label: 'Window Width',     min: 1,    max: 164, step: 0.5 },
    { key: 'radius_osc',       label: 'Radius Osc',       min: 1,    max: 164, step: 0.5 },
    { key: 'x_amp',            label: 'X Amplitude',      min: 1,    max: 116, step: 0.5 },
    { key: 'y_amp',            label: 'Y Amplitude',      min: 1,    max: 116, step: 0.5 },
    { key: 'x_cycle_sec',      label: 'X Cycle (s)',      min: 1,    max: 120, step: 1 },
    { key: 'y_cycle_sec',      label: 'Y Cycle (s)',      min: 1,    max: 120, step: 1 }
  ];

  var nextBtn, prevBtn;

  function init() {
    listEl = document.getElementById('pattern-list');
    nextBtn = document.getElementById('pattern-next');
    prevBtn = document.getElementById('pattern-prev');
    
    if (nextBtn) {
      nextBtn.onclick = function() { navigate('/api/patterns/next'); };
    }
    if (prevBtn) {
      prevBtn.onclick = function() { navigate('/api/patterns/prev'); };
    }
  }

  function navigate(url) {
    if (nextBtn) nextBtn.disabled = true;
    if (prevBtn) prevBtn.disabled = true;
    // Clear modified state - switching patterns discards unsaved edits
    if (Kwal.state) Kwal.state.clearPatternModified();
    editingId = null;
    currentParams = null;
    expandedId = null;
    fetch(url, { method: 'POST' })
      .then(function(r) {
        if (r.ok) {
          load();
          // Status labels come from SSE state event, no need to call load()
        }
      })
      .finally(function() {
        if (nextBtn) nextBtn.disabled = false;
        if (prevBtn) prevBtn.disabled = false;
      });
  }

  function load() {
    if (!listEl) return;

    fetch('/api/patterns')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        activeId = data.active_pattern;
        patternsData = data.patterns || [];
        renderList();
      })
      .catch(function(err) {
        console.error('Pattern load failed:', err);
        listEl.innerHTML = '<p style="color:#f88">Laden mislukt</p>';
      });
  }

  function renderList() {
    listEl.innerHTML = '';
    var canDelete = patternsData.length > 1;
    patternsData.forEach(function(p) {
      var item = document.createElement('div');
      item.className = 'pattern-item' + (p.id === activeId ? ' active' : '');
      
      var header = document.createElement('div');
      header.className = 'pattern-header';
      
      var label = document.createElement('span');
      label.className = 'pattern-label';
      label.textContent = p.label;
      label.onclick = function() { selectPattern(p.id); };
      
      var editBtn = document.createElement('span');
      editBtn.className = 'pattern-edit-btn';
      editBtn.textContent = 'â–¼';
      editBtn.onclick = function(e) { e.stopPropagation(); toggleExpand(p); };
      
      header.appendChild(label);
      header.appendChild(editBtn);
      
      // Delete button (only if more than 1 pattern)
      if (canDelete) {
        var delBtn = document.createElement('button');
        delBtn.className = 'btn-delete';
        delBtn.textContent = 'ðŸ—‘';
        delBtn.title = 'Verwijder';
        delBtn.onclick = function(e) { e.stopPropagation(); deletePattern(p.id, p.label); };
        header.appendChild(delBtn);
      }
      
      item.appendChild(header);
      
      // Expanded slider panel
      if (expandedId === p.id) {
        var panel = createSliderPanel(p);
        item.appendChild(panel);
      }
      
      listEl.appendChild(item);
    });
  }

  function deletePattern(id, label) {
    if (!confirm('Verwijder "' + label + '"?')) return;
    fetch('/api/patterns/delete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) return r.json();
        throw new Error('Delete failed');
      })
      .then(function(data) {
        // Update from response
        activeId = data.active_pattern;
        patternsData = data.patterns || [];
        editingId = null;
        currentParams = null;
        expandedId = null;
        renderList();
        // Status labels come from SSE state event
      })
      .catch(function(err) {
        console.error('Delete pattern failed:', err);
        alert('Verwijderen mislukt');
      });
  }

  function selectPattern(id) {
    fetch('/api/patterns/select', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) {
          activeId = id;
          editingId = null;
          originalLabel = null;
          currentParams = null;
          expandedId = null;
          renderList();
          // Status labels come from SSE state event
          if (Kwal.state) Kwal.state.clearPatternModified();
        }
      })
      .catch(function() {});
  }

  function toggleExpand(pattern) {
    if (expandedId === pattern.id) {
      expandedId = null;
    } else {
      expandedId = pattern.id;
      editingId = pattern.id;
      originalLabel = pattern.label;
      currentParams = JSON.parse(JSON.stringify(pattern.params));
      
      // Store original for revert
      if (Kwal.state && !Kwal.state.isPatternModified()) {
        Kwal.state.setPatternModified(false, pattern.id);
      }
      
      // Select this pattern
      fetch('/api/patterns/select', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: pattern.id })
      }).then(function() {
        activeId = pattern.id;
        // Status labels come from SSE state event
      });
    }
    renderList();
  }

  function createSliderPanel(pattern) {
    var panel = document.createElement('div');
    panel.className = 'pattern-sliders';
    
    var params = currentParams || pattern.params;
    
    PARAMS.forEach(function(def) {
      var row = document.createElement('div');
      row.className = 'slider-row';
      
      var lbl = document.createElement('label');
      lbl.textContent = def.label;
      
      var isLog = (def.key !== 'gradient_speed');
      var realValue = params[def.key] || def.min;
      
      var slider = document.createElement('input');
      slider.type = 'range';
      slider.min = def.min;
      slider.max = def.max;
      slider.step = def.step;
      slider.value = isLog ? Kwal.valueToSlider(realValue, def.min, def.max) : realValue;
      
      var val = document.createElement('span');
      val.className = 'slider-val';
      
      function formatValue(v) {
        return (def.step < 1) ? Number(v.toFixed(2)) : Math.round(v);
      }
      val.textContent = formatValue(realValue);
      
      slider.oninput = function() {
        var pos = parseFloat(slider.value);
        var real = isLog ? Kwal.sliderToValue(pos, def.min, def.max) : pos;
        // Snap to step
        real = Math.round(real / def.step) * def.step;
        real = Math.max(def.min, Math.min(def.max, real));
        val.textContent = formatValue(real);
        currentParams[def.key] = parseFloat(formatValue(real));
        schedulePreview();
        
        // Mark as modified
        if (Kwal.state) {
          Kwal.state.setPatternModified(true, editingId);
        }
      };
      
      row.appendChild(lbl);
      row.appendChild(slider);
      row.appendChild(val);
      panel.appendChild(row);
    });
    
    return panel;
  }

  function schedulePreview() {
    if (previewTimeout) clearTimeout(previewTimeout);
    previewTimeout = setTimeout(doPreview, 150);
  }

  function doPreview() {
    if (!currentParams) return;
    fetch('/api/patterns/preview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ params: currentParams })
    });
  }

  // Called from save modal
  function saveCurrentPattern(label) {
    if (!currentParams) return Promise.reject('No params');
    var payload = {
      label: label,
      params: currentParams,
      select: true
    };
    // Only include id if label unchanged (update existing), omit id to create new
    if (label === originalLabel && editingId) {
      payload.id = editingId;
    }
    return fetch('/api/patterns', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
      .then(function(r) { return r.json(); })
      .then(function() {
        if (Kwal.state) Kwal.state.clearPatternModified();
        expandedId = null;
        load(); // Refresh list
      });
  }

  function getCurrentLabel() {
    if (!editingId) return '';
    var p = patternsData.find(function(x) { return x.id === editingId; });
    return p ? p.label : '';
  }

  /**
   * Update active pattern indicator from SSE event (no server call)
   * @param {string} id - Pattern ID
   */
  function setActiveById(id) {
    if (id && id !== activeId) {
      activeId = id;
      renderList();
    }
  }

  /**
   * Update patterns list from SSE event data
   * @param {object} data - {active_pattern, patterns: [...]}
   */
  function updateFromSSE(data) {
    activeId = data.active_pattern;
    patternsData = data.patterns || [];
    editingId = null;
    currentParams = null;
    expandedId = null;
    renderList();
  }

  return {
    init: init,
    load: load,
    saveCurrentPattern: saveCurrentPattern,
    getCurrentLabel: getCurrentLabel,
    setActiveById: setActiveById,
    updateFromSSE: updateFromSSE
  };
})();


// === js/colorpicker.js ===
/*
 * Kwal - Custom Color Picker module
 * Canvas-based HSV picker that works on all browsers including
 * Android WebView (DuckDuckGo, etc.) where <input type="color"> fails.
 *
 * API:
 *   Kwal.colorpicker.open(currentHex, onSelect)
 *     currentHex: '#rrggbb' initial color
 *     onSelect:   function(hex) called on OK with chosen '#rrggbb'
 */
Kwal.colorpicker = (function() {
  'use strict';

  var modal, svCanvas, svCtx, hueCanvas, hueCtx;
  var hexInput, previewEl, okBtn, cancelBtn;
  var onSelectCb = null;

  // Current HSV state (h: 0-360, s: 0-1, v: 0-1)
  var curH = 0, curS = 1, curV = 1;

  var SV_SIZE = 200;   // saturation-value square side
  var HUE_W = 200;     // hue bar width (matches SV)
  var HUE_H = 24;      // hue bar height

  var draggingSV = false;
  var draggingHue = false;

  function init() {
    modal = document.getElementById('colorpicker-modal');
    if (!modal) return;

    svCanvas   = document.getElementById('cp-sv');
    hueCanvas  = document.getElementById('cp-hue');
    hexInput   = document.getElementById('cp-hex');
    previewEl  = document.getElementById('cp-preview');
    okBtn      = document.getElementById('cp-ok');
    cancelBtn  = document.getElementById('cp-cancel');

    if (!svCanvas || !hueCanvas) return;

    // Size canvases
    svCanvas.width  = SV_SIZE;
    svCanvas.height = SV_SIZE;
    hueCanvas.width = HUE_W;
    hueCanvas.height = HUE_H;

    svCtx  = svCanvas.getContext('2d');
    hueCtx = hueCanvas.getContext('2d');

    // --- SV canvas events (mouse + touch) ---
    svCanvas.addEventListener('mousedown', function(e) { draggingSV = true; pickSV(e); });
    document.addEventListener('mousemove', function(e) { if (draggingSV) pickSV(e); });
    document.addEventListener('mouseup', function() { draggingSV = false; });

    svCanvas.addEventListener('touchstart', function(e) {
      e.preventDefault(); draggingSV = true; pickSV(e.touches[0]);
    }, { passive: false });
    svCanvas.addEventListener('touchmove', function(e) {
      e.preventDefault(); if (draggingSV) pickSV(e.touches[0]);
    }, { passive: false });
    svCanvas.addEventListener('touchend', function() { draggingSV = false; });

    // --- Hue bar events ---
    hueCanvas.addEventListener('mousedown', function(e) { draggingHue = true; pickHue(e); });
    document.addEventListener('mousemove', function(e) { if (draggingHue) pickHue(e); });
    document.addEventListener('mouseup', function() { draggingHue = false; });

    hueCanvas.addEventListener('touchstart', function(e) {
      e.preventDefault(); draggingHue = true; pickHue(e.touches[0]);
    }, { passive: false });
    hueCanvas.addEventListener('touchmove', function(e) {
      e.preventDefault(); if (draggingHue) pickHue(e.touches[0]);
    }, { passive: false });
    hueCanvas.addEventListener('touchend', function() { draggingHue = false; });

    // Hex input
    if (hexInput) {
      hexInput.addEventListener('input', function() {
        var v = hexInput.value.trim();
        if (/^#[0-9a-fA-F]{6}$/.test(v)) {
          var hsv = hexToHSV(v);
          curH = hsv.h; curS = hsv.s; curV = hsv.v;
          drawAll();
        }
      });
    }

    // OK / Cancel
    if (okBtn) okBtn.onclick = function() {
      if (onSelectCb) onSelectCb(hsvToHex(curH, curS, curV));
      closeModal();
    };
    if (cancelBtn) cancelBtn.onclick = function() { closeModal(); };

    // Backdrop click closes
    modal.onclick = function(e) { if (e.target === modal) closeModal(); };
  }

  function open(hex, onSelect) {
    if (!modal) return;
    onSelectCb = onSelect;
    var hsv = hexToHSV(hex || '#ff0000');
    curH = hsv.h; curS = hsv.s; curV = hsv.v;
    modal.classList.add('open');
    drawAll();
  }

  function closeModal() {
    if (modal) modal.classList.remove('open');
    onSelectCb = null;
    draggingSV = false;
    draggingHue = false;
  }

  // --- Drawing ---

  function drawAll() {
    drawSV();
    drawHue();
    updatePreview();
  }

  function drawSV() {
    if (!svCtx) return;
    var w = SV_SIZE, h = SV_SIZE;

    // Base hue fill
    svCtx.fillStyle = 'hsl(' + curH + ',100%,50%)';
    svCtx.fillRect(0, 0, w, h);

    // White gradient left-to-right (saturation)
    var gWhite = svCtx.createLinearGradient(0, 0, w, 0);
    gWhite.addColorStop(0, 'rgba(255,255,255,1)');
    gWhite.addColorStop(1, 'rgba(255,255,255,0)');
    svCtx.fillStyle = gWhite;
    svCtx.fillRect(0, 0, w, h);

    // Black gradient top-to-bottom (value)
    var gBlack = svCtx.createLinearGradient(0, 0, 0, h);
    gBlack.addColorStop(0, 'rgba(0,0,0,0)');
    gBlack.addColorStop(1, 'rgba(0,0,0,1)');
    svCtx.fillStyle = gBlack;
    svCtx.fillRect(0, 0, w, h);

    // Crosshair
    var cx = curS * w;
    var cy = (1 - curV) * h;
    svCtx.beginPath();
    svCtx.arc(cx, cy, 6, 0, Math.PI * 2);
    svCtx.strokeStyle = '#fff';
    svCtx.lineWidth = 2;
    svCtx.stroke();
    svCtx.beginPath();
    svCtx.arc(cx, cy, 7, 0, Math.PI * 2);
    svCtx.strokeStyle = '#000';
    svCtx.lineWidth = 1;
    svCtx.stroke();
  }

  function drawHue() {
    if (!hueCtx) return;
    var w = HUE_W, h = HUE_H;
    var grad = hueCtx.createLinearGradient(0, 0, w, 0);
    for (var i = 0; i <= 6; i++) {
      grad.addColorStop(i / 6, 'hsl(' + (i * 60) + ',100%,50%)');
    }
    hueCtx.fillStyle = grad;
    hueCtx.fillRect(0, 0, w, h);

    // Indicator
    var ix = (curH / 360) * w;
    hueCtx.beginPath();
    hueCtx.rect(ix - 3, 0, 6, h);
    hueCtx.strokeStyle = '#fff';
    hueCtx.lineWidth = 2;
    hueCtx.stroke();
    hueCtx.beginPath();
    hueCtx.rect(ix - 4, 0, 8, h);
    hueCtx.strokeStyle = '#000';
    hueCtx.lineWidth = 1;
    hueCtx.stroke();
  }

  function updatePreview() {
    var hex = hsvToHex(curH, curS, curV);
    if (previewEl) previewEl.style.background = hex;
    if (hexInput) hexInput.value = hex;
  }

  // --- Coordinate picking ---

  function pickSV(e) {
    var r = svCanvas.getBoundingClientRect();
    var x = (e.clientX - r.left);
    var y = (e.clientY - r.top);
    curS = Math.max(0, Math.min(1, x / SV_SIZE));
    curV = Math.max(0, Math.min(1, 1 - y / SV_SIZE));
    drawAll();
  }

  function pickHue(e) {
    var r = hueCanvas.getBoundingClientRect();
    var x = (e.clientX - r.left);
    curH = Math.max(0, Math.min(360, (x / HUE_W) * 360));
    drawAll();
  }

  // --- Color conversion ---

  function hsvToRGB(h, s, v) {
    var c = v * s;
    var x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    var m = v - c;
    var r = 0, g = 0, b = 0;
    if      (h < 60)  { r = c; g = x; }
    else if (h < 120) { r = x; g = c; }
    else if (h < 180) { g = c; b = x; }
    else if (h < 240) { g = x; b = c; }
    else if (h < 300) { r = x; b = c; }
    else              { r = c; b = x; }
    return {
      r: Math.round((r + m) * 255),
      g: Math.round((g + m) * 255),
      b: Math.round((b + m) * 255)
    };
  }

  function hsvToHex(h, s, v) {
    var rgb = hsvToRGB(h, s, v);
    return '#' + pad2(rgb.r) + pad2(rgb.g) + pad2(rgb.b);
  }

  function hexToHSV(hex) {
    var r = parseInt(hex.substr(1, 2), 16) / 255;
    var g = parseInt(hex.substr(3, 2), 16) / 255;
    var b = parseInt(hex.substr(5, 2), 16) / 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var d = max - min;
    var h = 0, s = max === 0 ? 0 : d / max, v = max;
    if (d !== 0) {
      if (max === r)      h = 60 * (((g - b) / d) % 6);
      else if (max === g) h = 60 * ((b - r) / d + 2);
      else                h = 60 * ((r - g) / d + 4);
      if (h < 0) h += 360;
    }
    return { h: h, s: s, v: v };
  }

  function pad2(n) {
    var s = n.toString(16);
    return s.length < 2 ? '0' + s : s;
  }

  return { init: init, open: open };
})();


// === js/colors.js ===
/*
 * Kwal - Colors module
 * API: GET /api/colors, POST /api/colors/select, POST /api/colors/preview
 */
Kwal.colors = (function() {
  'use strict';

  var listEl, activeId, colorsData = [];
  var editingId = null;
  var originalLabel = null;
  var editingColor = null; // 'a' or 'b'
  var currentA = null, currentB = null;
  var previewTimeout = null;
  var nextBtn, prevBtn;

  function init() {
    listEl = document.getElementById('colors-list');
    nextBtn = document.getElementById('colors-next');
    prevBtn = document.getElementById('colors-prev');
    
    if (nextBtn) {
      nextBtn.onclick = function() { navigate('/api/colors/next'); };
    }
    if (prevBtn) {
      prevBtn.onclick = function() { navigate('/api/colors/prev'); };
    }
  }

  function navigate(url) {
    if (nextBtn) nextBtn.disabled = true;
    if (prevBtn) prevBtn.disabled = true;
    // Clear modified state - switching colors discards unsaved edits
    if (Kwal.state) Kwal.state.clearColorsModified();
    editingId = null;
    currentA = null;
    currentB = null;
    fetch(url, { method: 'POST' })
      .then(function(r) {
        if (r.ok) {
          load();
          // Status labels come from SSE state event
        }
      })
      .finally(function() {
        if (nextBtn) nextBtn.disabled = false;
        if (prevBtn) prevBtn.disabled = false;
      });
  }

  function load() {
    if (!listEl) return;

    fetch('/api/colors')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        activeId = data.active_color;
        colorsData = data.colors || [];
        renderList();
      })
      .catch(function(err) {
        console.error('Colors load failed:', err);
        listEl.innerHTML = '<p style="color:#f88">Laden mislukt</p>';
      });
  }

  function renderList() {
    listEl.innerHTML = '';
    var canDelete = colorsData.length > 1;
    colorsData.forEach(function(c) {
      var item = document.createElement('div');
      item.className = 'color-item' + (c.id === activeId ? ' active' : '');
      
      // Use current editing values if this is the item being edited
      var displayA = (c.id === editingId && currentA) ? currentA : c.colorA_hex;
      var displayB = (c.id === editingId && currentB) ? currentB : c.colorB_hex;
      
      var swatchA = createSwatchBox(c, 'a', displayA);
      var swatchB = createSwatchBox(c, 'b', displayB);
      
      var swatchDiv = document.createElement('div');
      swatchDiv.className = 'color-swatch';
      swatchDiv.appendChild(swatchA);
      swatchDiv.appendChild(swatchB);
      
      var label = document.createElement('span');
      label.className = 'color-label';
      label.textContent = c.label;
      label.onclick = function() { selectColor(c.id); };
      
      item.appendChild(swatchDiv);
      item.appendChild(label);
      
      // Delete button (only if more than 1 color set)
      if (canDelete) {
        var delBtn = document.createElement('button');
        delBtn.className = 'btn-delete';
        delBtn.textContent = 'ðŸ—‘';
        delBtn.title = 'Verwijder';
        delBtn.onclick = function(e) { e.stopPropagation(); deleteColorSet(c.id, c.label); };
        item.appendChild(delBtn);
      }
      
      listEl.appendChild(item);
    });
  }

  function deleteColorSet(id, label) {
    if (!confirm('Verwijder "' + label + '"?')) return;
    fetch('/api/colors/delete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) return r.json();
        throw new Error('Delete failed');
      })
      .then(function(data) {
        // Update from response
        activeId = data.active_color;
        colorsData = data.colors || [];
        renderList();
        // Status labels come from SSE state event
      })
      .catch(function(err) {
        console.error('Delete color failed:', err);
        alert('Verwijderen mislukt');
      });
  }

  function selectColor(id) {
    fetch('/api/colors/select', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) {
          activeId = id;
          editingId = null;
          originalLabel = null;
          currentA = null;
          currentB = null;
          renderList();
          // Status labels come from SSE state event
          if (Kwal.state) Kwal.state.clearColorsModified();
        }
      })
      .catch(function() {});
  }

  /**
   * Create a swatch box that opens the custom canvas color picker on tap.
   * Works on all browsers (no <input type="color"> dependency).
   */
  function createSwatchBox(colorSet, which, displayColor) {
    var box = document.createElement('span');
    box.className = 'color-swatch-box';
    box.style.background = displayColor;

    box.onclick = function(e) {
      e.stopPropagation();
      activateEditing(colorSet);
      editingColor = which;
      var startHex = (which === 'a') ? currentA : currentB;
      Kwal.colorpicker.open(startHex, function(hex) {
        if (which === 'a') {
          currentA = hex;
        } else {
          currentB = hex;
        }
        schedulePreview();
        renderList();
        // Mark as modified
        if (Kwal.state) {
          var orig = Kwal.state.getOriginalColors();
          Kwal.state.setColorsModified(true, orig.a, orig.b, orig.id);
        }
      });
    };

    return box;
  }

  function activateEditing(colorSet) {
    if (editingId === colorSet.id) return;
    editingId = colorSet.id;
    originalLabel = colorSet.label;
    currentA = colorSet.colorA_hex;
    currentB = colorSet.colorB_hex;

    // Store original for revert
    if (Kwal.state && !Kwal.state.isColorsModified()) {
      Kwal.state.setColorsModified(false, currentA, currentB, editingId);
    }

    // Select and display
    fetch('/api/colors/select', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: editingId })
    }).then(function() {
      activeId = editingId;
      renderList();
      // Status labels come from SSE state event
    });
  }

  function schedulePreview() {
    if (previewTimeout) clearTimeout(previewTimeout);
    previewTimeout = setTimeout(doPreview, 150);
  }

  function doPreview() {
    if (!currentA || !currentB) return;
    fetch('/api/colors/preview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ colorA_hex: currentA, colorB_hex: currentB })
    });
  }

  // Called from save modal
  function saveCurrentColors(label) {
    if (!currentA || !currentB) return Promise.reject('No colors');
    var payload = {
      label: label,
      colorA_hex: currentA,
      colorB_hex: currentB,
      select: true
    };
    // Only include id if label unchanged (update existing), omit id to create new
    if (label === originalLabel && editingId) {
      payload.id = editingId;
    }
    return fetch('/api/colors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
      .then(function(r) { return r.json(); })
      .then(function() {
        if (Kwal.state) Kwal.state.clearColorsModified();
        load(); // Refresh list
      });
  }

  function getCurrentLabel() {
    if (!editingId) return '';
    var c = colorsData.find(function(x) { return x.id === editingId; });
    return c ? c.label : '';
  }

  /**
   * Update active color indicator from SSE event (no server call)
   * @param {string} id - Color ID
   */
  function setActiveById(id) {
    if (id && id !== activeId) {
      activeId = id;
      renderList();
    }
  }

  /**
   * Update colors list from SSE event data
   * @param {object} data - {active_color, colors: [...]}
   */
  function updateFromSSE(data) {
    activeId = data.active_color;
    colorsData = data.colors || [];
    editingId = null;
    currentA = null;
    currentB = null;
    renderList();
  }

  return {
    init: init,
    load: load,
    saveCurrentColors: saveCurrentColors,
    getCurrentLabel: getCurrentLabel,
    setActiveById: setActiveById,
    updateFromSSE: updateFromSSE
  };
})();


// === js/ota.js ===
/*
 * Kwal - OTA module
 * API: POST /ota/upload (multipart firmware binary)
 */
Kwal.ota = (function() {
  'use strict';

  var fileInput, uploadBtn, status, progressBar;

  function init() {
    fileInput   = document.getElementById('ota-file');
    uploadBtn   = document.getElementById('ota-upload');
    status      = document.getElementById('ota-status');
    progressBar = document.getElementById('ota-progress');

    if (uploadBtn) uploadBtn.onclick = uploadFirmware;
    if (fileInput) fileInput.onchange = function() {
      if (uploadBtn) uploadBtn.disabled = !fileInput.files.length;
      showStatus('', false);
    };
  }

  function uploadFirmware() {
    if (!fileInput || !fileInput.files.length) {
      showStatus('Kies eerst een .bin bestand', true);
      return;
    }
    var file = fileInput.files[0];
    if (file.size < 10000) {
      showStatus('Bestand te klein - kies firmware .bin', true);
      return;
    }

    if (uploadBtn) uploadBtn.disabled = true;
    showStatus('Uploading ' + file.name + ' (' + formatSize(file.size) + ')...', false);
    setProgress(0);

    var formData = new FormData();
    formData.append('firmware', file, file.name);

    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/ota/upload', true);

    xhr.upload.onprogress = function(e) {
      if (e.lengthComputable) {
        var pct = Math.round(e.loaded / e.total * 100);
        setProgress(pct);
        showStatus('Uploading... ' + pct + '%', false);
      }
    };

    xhr.onload = function() {
      if (xhr.status === 200) {
        setProgress(100);
        showStatus('Upload OK! Rebooting...', false);
        setTimeout(waitForReboot, 5000);
      } else {
        var errMsg = 'Upload mislukt';
        try { errMsg = JSON.parse(xhr.responseText).error || errMsg; } catch(e) {}
        showStatus(errMsg, true);
        resetButtons();
      }
    };

    xhr.onerror = function() {
      showStatus('Verbinding mislukt', true);
      resetButtons();
    };

    xhr.send(formData);
  }

  function waitForReboot() {
    var attempts = 0;
    var maxAttempts = 30;
    showStatus('Wachten op herstart...', false);

    var timer = setInterval(function() {
      attempts++;
      fetch('/api/health', { method: 'GET' })
        .then(function(r) {
          if (r.ok) {
            clearInterval(timer);
            showStatus('Herstart gelukt! Pagina ververst...', false);
            setTimeout(function() { location.reload(); }, 1500);
          }
        })
        .catch(function() {
          if (attempts >= maxAttempts) {
            clearInterval(timer);
            showStatus('Timeout - ververs pagina handmatig', true);
            resetButtons();
          }
        });
    }, 2000);
  }

  function setProgress(pct) {
    if (progressBar) {
      progressBar.value = pct;
      progressBar.style.display = pct > 0 ? '' : 'none';
    }
  }

  function resetButtons() {
    if (uploadBtn) uploadBtn.disabled = !fileInput || !fileInput.files.length;
    setProgress(0);
  }

  function showStatus(msg, isError) {
    if (status) {
      status.textContent = msg;
      status.className = isError ? 'err' : '';
    }
  }

  function formatSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / 1048576).toFixed(1) + ' MB';
  }

  return { init: init };
})();

// === js/status.js ===
/*
 * Kwal - Status module
 * Shows current active pattern and colors on main screen
 * Labels now come from SSE state event (patternLabel, colorLabel)
 */
Kwal.status = (function() {
  'use strict';

  var patternLabel, colorsLabel;

  function init() {
    patternLabel = document.getElementById('current-pattern');
    colorsLabel = document.getElementById('current-colors');
    // No load() - labels come from SSE state event
  }

  /**
   * Update labels from SSE state event
   * @param {string} pattern - Pattern label
   * @param {string} color - Color label
   */
  function updateFromState(pattern, color) {
    if (patternLabel) {
      patternLabel.textContent = pattern || '-';
    }
    if (colorsLabel) {
      colorsLabel.textContent = color || '-';
    }
  }

  // Keep load() for backward compatibility but it does nothing now
  function load() {}

  return { init: init, load: load, updateFromState: updateFromState };
})();


// === js/health.js ===
/*
 * Kwal - Health module
 * System health status display in DEV modal
 * API: GET /api/health, POST /api/restart
 */
Kwal.health = (function() {
  'use strict';

  // Health bit definitions (must match AlertState::getHealthBits())
  // KRITIEK: Volgorde MOET matchen met enum StatusComponent in AlertState.h!
  var FLAGS = [
    { bit: 0, name: 'SD',       icon: 'ðŸ’¾' },
    { bit: 1, name: 'WiFi',     icon: 'ðŸ“¶' },
    { bit: 2, name: 'RTC',      icon: 'ðŸ•' },
    { bit: 3, name: 'Audio',    icon: 'ðŸ”Š' },
    { bit: 4, name: 'Distance', icon: 'ðŸ“' },
    { bit: 5, name: 'Lux',      icon: 'â˜€ï¸' },
    { bit: 6, name: 'Sensor3',  icon: 'ðŸŒ¡ï¸' },
    { bit: 7, name: 'NTP',      icon: 'â°' },
    { bit: 8, name: 'Weather',  icon: 'ðŸŒ¤ï¸' },
    { bit: 9, name: 'Calendar', icon: 'ðŸ“…' },
    { bit: 10, name: 'TTS',     icon: 'ðŸ—£ï¸' },
    { bit: 11, name: 'NAS',     icon: 'ðŸ—„ï¸' }
  ];

  // Status values for 4-bit fields (must match AlertState.h)
  var STATUS_OK = 0;
  var STATUS_NOTOK = 15;

  var container, restartBtn;

  // Extract 4-bit field from boot status uint64
  // Note: JS handles numbers up to 2^53 safely, uint64 fits
  function getStatusField(bootStatus, index) {
    return (bootStatus / Math.pow(16, index)) & 0xF | 0;
  }

  // Render status icon based on 4-bit value
  function renderStatus(value) {
    if (value === STATUS_OK) return 'âœ…';
    if (value === STATUS_NOTOK) return 'âŒ';
    return 'âŸ³' + value;
  }

  function init() {
    container = document.getElementById('health-content');
    restartBtn = document.getElementById('restart-btn');
    if (restartBtn) {
      restartBtn.onclick = doRestart;
    }
  }

  function load() {
    if (!container) return;
    container.innerHTML = '<em>Loading...</em>';

    fetch('/api/health')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        render(data);
      })
      .catch(function(err) {
        container.innerHTML = '<em>Error: ' + err.message + '</em>';
      });
  }

  function render(data) {
    if (!container) return;

    // Update title with date
    var titleEl = document.getElementById('health-title');
    if (titleEl) {
      titleEl.textContent = 'Status' + (data.ntpDate ? ' ' + data.ntpDate : '');
    }

    var html = '<table class="health-table">';

    // Flags with boot status (use boot field if available, fallback to health bits)
    var healthBits = data.health || 0;
    var bootStatus = data.boot || 0;
    var absentBits = data.absent || 0;
    var useBoot = (data.boot !== undefined);
    
    for (var i = 0; i < FLAGS.length; i++) {
      var f = FLAGS[i];
      var status;
      // Check if hardware is absent (not present per HWconfig)
      if (absentBits & (1 << f.bit)) {
        status = 'â€”';
      } else if (useBoot) {
        var value = getStatusField(bootStatus, f.bit);
        status = renderStatus(value);
      } else {
        var ok = (healthBits & (1 << f.bit)) !== 0;
        status = ok ? 'âœ…' : 'âŒ';
      }
      // Append RTC temperature after RTC status
      if (f.name === 'RTC' && data.rtcTempC !== undefined) {
        status += ' ' + data.rtcTempC.toFixed(1) + 'Â°';
      }
      // Append theme box name after Audio status
      if (f.name === 'Audio' && data.themeBox) {
        status += ' ' + data.themeBox;
      }
      // Append time after NTP status
      if (f.name === 'NTP' && data.ntpTime) {
        status += ' ' + data.ntpTime;
      }
      // Append calendar date after Calendar status
      if (f.name === 'Calendar' && data.calendarDate) {
        status += ' ' + data.calendarDate;
      }
      html += '<tr><td>' + f.icon + ' ' + f.name + '</td><td>' + status + '</td></tr>';
    }

    // Heap as component row
    if (data.heapFree !== undefined) {
      html += '<tr><td>ðŸ§  Heap</td><td>' + data.heapFree + '>' + data.heapMin + 'KB (' + data.heapBlock + ')</td></tr>';
    }

    // Timers as component row
    if (data.maxActiveTimers !== undefined) {
      html += '<tr><td>â±ï¸ Timers</td><td>max ' + data.maxActiveTimers + ' of ' + data.maxTimers + ' used</td></tr>';
    }

    // Version info
    html += '<tr><td>Firmware</td><td>' + (data.firmware || '?') + '</td></tr>';
    html += '<tr><td>WebGUI</td><td>' + (window.KWAL_JS_VERSION || '?') + '</td></tr>';

    html += '</table>';
    container.innerHTML = html;
  }

  function doRestart() {
    if (restartBtn) restartBtn.disabled = true;
    fetch('/api/restart', { method: 'POST' })
      .then(function(r) {
        if (!r.ok) throw new Error(r.statusText);
        if (restartBtn) restartBtn.textContent = 'Restarting...';
        setTimeout(function() { location.reload(); }, 5000);
      })
      .catch(function(err) {
        alert('Restart failed: ' + err.message);
        if (restartBtn) restartBtn.disabled = false;
      });
  }

  return { init: init, load: load };
})();


// === js/log.js ===
(function() {
  'use strict';
  
  function fetchLog() {
    var pre = document.getElementById('log-content');
    if (!pre) return;
    
    fetch('/log')
      .then(function(r) { return r.text(); })
      .then(function(txt) { 
        pre.textContent = txt || '(empty)';
        pre.scrollTop = pre.scrollHeight;
      })
      .catch(function(e) { pre.textContent = 'Error: ' + e; });
  }
  
  function clearLog() {
    fetch('/log/clear')
      .then(function() { fetchLog(); })
      .catch(function(e) { console.error('Clear failed:', e); });
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    var refreshBtn = document.getElementById('log-refresh');
    var clearBtn = document.getElementById('log-clear');
    
    if (refreshBtn) refreshBtn.onclick = fetchLog;
    if (clearBtn) clearBtn.onclick = clearLog;
    
    // Auto-fetch when modal opens
    var logModal = document.getElementById('log-modal');
    if (logModal) {
      var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(m) {
          if (m.attributeName === 'class' && 
              logModal.classList.contains('open')) {
            fetchLog();
          }
        });
      });
      observer.observe(logModal, { attributes: true });
    }
  });
})();


// === js/mp3grid.js ===
/*
 * Kwal - MP3 Grid module
 * Canvas grid showing dirs from root_dirs index + theme box colors.
 * One-shot load via /api/audio/grid; crosshair follows SSE fragment events.
 */
Kwal.mp3grid = (function() {
  'use strict';

  var COLS = 101;   // file 1-100 (column 0 unused)
  var ROWS = 200;   // dir 1-199
  var CELL = 5;
  var W = COLS * CELL;
  var H = ROWS * CELL;

  var canvas, ctx, wrap;
  var dirSlider, fileSlider, dirVal, fileVal;
  var catpill, catlabel, closeBtn;

  var selRow = 0, selCol = 0;
  var loaded = false;

  // Data from /api/audio/grid
  var boxById = {};           // id â†’ {name, color}
  var dirBox = null;          // Uint8Array[ROWS] dir â†’ box id
  var dirFileCount = null;    // Uint16Array[ROWS] dir â†’ number of files

  function hexToRgb(hex) {
    var h = hex.replace('#', '');
    if (h.length === 3) h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2];
    var n = parseInt(h, 16);
    return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
  }

  function fmt3(n) { return String(n).padStart(3, '0'); }

  function draw() {
    if (!ctx || !loaded) return;

    // Base fill (dark)
    ctx.fillStyle = '#060619';
    ctx.fillRect(0, 0, W, H);

    // Per-dir: colored bar proportional to fileCount
    for (var r = 0; r < ROWS; r++) {
      var bid = dirBox[r];
      if (!bid) continue;
      var box = boxById[bid];
      if (!box) continue;
      var rgb = hexToRgb(box.color);
      var y = r * CELL;
      var fc = dirFileCount[r];

      // Fill bar: width proportional to fileCount (max COLS)
      var barW = fc > 0 ? Math.min(fc, COLS) * CELL : 0;
      if (barW > 0) {
        ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0.35)';
        ctx.fillRect(0, y, barW, CELL);
      }

      // Category line: 1px horizontal, same width as bar
      if (barW > 0) {
        ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0.95)';
        ctx.fillRect(0, y + 1, barW, 1);
      }
    }

    // Vertical gridlines
    ctx.fillStyle = 'rgba(255,255,255,0.035)';
    for (var c = 1; c < COLS; c++) {
      ctx.fillRect(c * CELL, 0, 1, H);
    }

    // Row separators (black; white for selected row edges)
    for (var r = 0; r <= ROWS; r++) {
      var isSelEdge = (r === selRow) || (r === selRow + 1);
      ctx.fillStyle = isSelEdge ? '#ffffff' : '#000000';
      ctx.fillRect(0, r * CELL, W, 1);
    }

    // Selected column highlight
    ctx.fillStyle = 'rgba(255,225,64,0.55)';
    ctx.fillRect(selCol * CELL, 0, CELL, H);

    // Intersection cell: white
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(selCol * CELL, selRow * CELL, CELL, CELL);
  }

  function updateHeader() {
    if (dirVal) dirVal.textContent = fmt3(selRow);
    if (fileVal) fileVal.textContent = fmt3(selCol);
    var bid = (dirBox && selRow < ROWS) ? dirBox[selRow] : 0;
    var box = boxById[bid];
    if (catlabel) catlabel.textContent = box ? box.name : '-';
    if (catpill) catpill.style.background = box ? box.color : '#444';
  }

  function keepRowVisible(row) {
    if (!wrap) return;
    var y = row * CELL;
    var viewTop = wrap.scrollTop;
    var viewH = wrap.clientHeight;
    var target = Math.max(0, y - Math.floor(viewH / 2));
    if (y < viewTop + CELL || y > viewTop + viewH - CELL) {
      wrap.scrollTop = target;
    }
  }

  function setSelection(row, col, scrollRow) {
    selRow = Math.max(0, Math.min(ROWS - 1, row | 0));
    selCol = Math.max(0, Math.min(COLS - 1, col | 0));
    if (dirSlider) dirSlider.value = selRow;
    if (fileSlider) fileSlider.value = selCol;
    updateHeader();
    if (scrollRow) keepRowVisible(selRow);
    draw();
  }

  function bindStepper(btn, deltaRow, deltaCol) {
    if (!btn) return;
    var timer = null, isDown = false;
    var step = function() { setSelection(selRow + deltaRow, selCol + deltaCol, !!deltaRow); };

    btn.addEventListener('pointerdown', function(e) {
      e.preventDefault();
      if (isDown) return;
      isDown = true;
      step();
      timer = setInterval(step, 130);
    });
    var stop = function() { isDown = false; if (timer) { clearInterval(timer); timer = null; } };
    btn.addEventListener('pointerup', stop);
    btn.addEventListener('pointercancel', stop);
    btn.addEventListener('pointerleave', stop);
    btn.addEventListener('click', function(e) { e.preventDefault(); });
  }

  function init() {
    canvas = document.getElementById('mg-grid');
    wrap = document.getElementById('mg-wrap');
    dirSlider = document.getElementById('mg-dir');
    fileSlider = document.getElementById('mg-file');
    dirVal = document.getElementById('mg-dir-val');
    fileVal = document.getElementById('mg-file-val');
    catpill = document.getElementById('mg-catpill');
    catlabel = document.getElementById('mg-catlabel');
    closeBtn = document.getElementById('mg-close');

    if (!canvas || !wrap) return;

    // HiDPI crisp canvas
    var dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx = canvas.getContext('2d', { alpha: false });
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Slider events
    if (dirSlider) dirSlider.oninput = function() {
      setSelection(parseInt(dirSlider.value, 10) || 0, selCol, true);
    };
    if (fileSlider) fileSlider.oninput = function() {
      setSelection(selRow, parseInt(fileSlider.value, 10) || 0, false);
    };

    // Canvas tap
    canvas.addEventListener('pointerdown', function(e) {
      var rect = canvas.getBoundingClientRect();
      var x = Math.max(0, Math.min(W - 1, Math.floor(e.clientX - rect.left)));
      var y = Math.max(0, Math.min(H - 1, Math.floor(e.clientY - rect.top)));
      setSelection(Math.floor(y / CELL), Math.floor(x / CELL), true);
    });

    // Canvas double-tap: play file if tapped on file column, set dir theme if tapped on dir label
    canvas.addEventListener('dblclick', function(e) {
      e.preventDefault();
      if (selRow > 0 && selCol > 0) {
        fetch('/api/audio/play?dir=' + selRow + '&file=' + selCol).catch(function() {});
      }
    });

    // Steppers
    bindStepper(document.getElementById('mg-dir-dec'), -1, 0);
    bindStepper(document.getElementById('mg-dir-inc'), 1, 0);
    bindStepper(document.getElementById('mg-file-dec'), 0, -1);
    bindStepper(document.getElementById('mg-file-inc'), 0, 1);

    // DIR label + value click: set single-dir theme_box
    var dirLabel = document.getElementById('mg-dir-label');
    var dirClickTargets = [dirVal, dirLabel];
    dirClickTargets.forEach(function(el) {
      if (!el) return;
      el.style.cursor = 'pointer';
      el.addEventListener('click', function(e) {
        e.preventDefault();
        if (selRow > 0) {
          fetch('/api/audio/themebox?dir=' + selRow).catch(function() {});
          if (dirVal) { dirVal.style.color = '#2ee88a'; setTimeout(function() { dirVal.style.color = ''; }, 400); }
        }
      });
    });

    // FILE label + value click: play that file
    var fileLabel = document.getElementById('mg-file-label');
    var fileClickTargets = [fileVal, fileLabel];
    fileClickTargets.forEach(function(el) {
      if (!el) return;
      el.style.cursor = 'pointer';
      el.addEventListener('click', function(e) {
        e.preventDefault();
        if (selRow > 0 && selCol > 0) {
          fetch('/api/audio/play?dir=' + selRow + '&file=' + selCol).catch(function() {});
          if (fileVal) { fileVal.style.color = '#e8c72e'; setTimeout(function() { fileVal.style.color = ''; }, 400); }
        }
      });
    });
  }

  function load() {
    if (loaded) { draw(); return; }
    fetch('/api/audio/grid')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        boxById = {};
        dirBox = new Uint8Array(ROWS);
        dirFileCount = new Uint16Array(ROWS);

        if (data.boxes) {
          data.boxes.forEach(function(b) {
            boxById[b.id] = { name: b.name, color: b.color };
          });
        }
        if (data.dirs) {
          data.dirs.forEach(function(d) {
            if (d.d < ROWS) {
              dirBox[d.d] = d.b;
              dirFileCount[d.d] = d.n;
            }
          });
        }
        loaded = true;
        draw();
        updateHeader();
      })
      .catch(function(e) { console.error('[mp3grid] load failed:', e); });
  }

  return {
    init: init,
    load: load,
    setSelection: setSelection
  };
})();


// === js/sse.js ===
/**
 * sse.js - Server-Sent Events for live updates
 * Events: state, patterns, colors (legacy: fragment, light)
 */
(function() {
    'use strict';
    
    let eventSource = null;
    let reconnectTimer = null;
    let hasConnectedOnce = false;
    const RECONNECT_POLL_MS = 2000;
    
    // Callbacks registered by other modules
    const listeners = {
        state: [],      // New unified state event
        fragment: [],   // Legacy (still fired by firmware)
        light: [],      // Legacy (still fired by firmware)
        colors: [],
        patterns: [],
        reconnect: []   // Called on reconnect to refresh state
    };
    
    function connect() {
        if (eventSource) {
            eventSource.close();
        }
        
        eventSource = new EventSource('/api/events');
        
        eventSource.onopen = function() {
            console.log('[SSE] Connected');
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            // On reconnect (not first connect), refresh all data
            // ESP32 may have rebooted with new random pattern/color
            if (hasConnectedOnce) {
                console.log('[SSE] Reconnected - refreshing state');
                listeners.reconnect.forEach(function(cb) { cb(); });
            }
            hasConnectedOnce = true;
        };
        
        eventSource.onerror = function(e) {
            console.warn('[SSE] Error, reconnecting...', e);
            eventSource.close();
            eventSource = null;
            scheduleReconnect();
        };
        
        // Unified state event (new)
        eventSource.addEventListener('state', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] state:', data);
                listeners.state.forEach(cb => cb(data));
            } catch (err) {
                console.error('[SSE] state parse error:', err);
            }
        });
        
        // Fragment change event (legacy)
        eventSource.addEventListener('fragment', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] fragment:', data);
                listeners.fragment.forEach(cb => cb(data.dir, data.file, data.score));
            } catch (err) {
                console.error('[SSE] fragment parse error:', err);
            }
        });
        
        // Light change event (pattern/color)
        eventSource.addEventListener('light', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] light:', data);
                listeners.light.forEach(cb => cb(data.pattern, data.color));
            } catch (err) {
                console.error('[SSE] light parse error:', err);
            }
        });
        
        // Colors list change event
        eventSource.addEventListener('colors', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] colors:', data);
                listeners.colors.forEach(cb => cb(data));
            } catch (err) {
                console.error('[SSE] colors parse error:', err);
            }
        });
        
        // Patterns list change event
        eventSource.addEventListener('patterns', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] patterns:', data);
                listeners.patterns.forEach(cb => cb(data));
            } catch (err) {
                console.error('[SSE] patterns parse error:', err);
            }
        });
    }
    
    function scheduleReconnect() {
        if (reconnectTimer) return;
        console.log('[SSE] Starting reconnect polling...');
        reconnectTimer = setInterval(async function() {
            try {
                const response = await fetch('/api/health');
                if (response.ok) {
                    console.log('[SSE] Device back online, reloading page...');
                    clearInterval(reconnectTimer);
                    reconnectTimer = null;
                    location.reload();
                }
            } catch (e) {
                // Still offline, keep polling
            }
        }, RECONNECT_POLL_MS);
    }
    
    function disconnect() {
        if (reconnectTimer) {
            clearInterval(reconnectTimer);
            reconnectTimer = null;
        }
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
    }
    
    /**
     * Register callback for fragment changes
     * @param {function(dir: number, file: number): void} cb
     */
    function onFragment(cb) {
        if (typeof cb === 'function') {
            listeners.fragment.push(cb);
        }
    }
    
    /**
     * Register callback for light changes
     * @param {function(patternId: string, colorId: string): void} cb
     */
    function onLight(cb) {
        if (typeof cb === 'function') {
            listeners.light.push(cb);
        }
    }
    
    /**
     * Register callback for colors list changes
     * @param {function(data: object): void} cb
     */
    function onColors(cb) {
        if (typeof cb === 'function') {
            listeners.colors.push(cb);
        }
    }
    
    /**
     * Register callback for patterns list changes
     * @param {function(data: object): void} cb
     */
    function onPatterns(cb) {
        if (typeof cb === 'function') {
            listeners.patterns.push(cb);
        }
    }
    
    /**
     * Register callback for reconnect (to refresh state after ESP32 reboot)
     * @param {function(): void} cb
     */
    function onReconnect(cb) {
        if (typeof cb === 'function') {
            listeners.reconnect.push(cb);
        }
    }
    
    /**
     * Register callback for unified state event
     * @param {function(data: {brightness, audioLevel, patternId, patternLabel, colorId, colorLabel, fragment}): void} cb
     */
    function onState(cb) {
        if (typeof cb === 'function') {
            listeners.state.push(cb);
        }
    }
    
    // Export
    Kwal.sse = {
        connect: connect,
        disconnect: disconnect,
        onState: onState,
        onFragment: onFragment,
        onLight: onLight,
        onColors: onColors,
        onPatterns: onPatterns,
        onReconnect: onReconnect
    };
})();


// === js/main.js ===
/*
 * Kwal WebGUI v1214C - Modular
 * Main entry point
 */
(function() {
  'use strict';

  document.addEventListener('DOMContentLoaded', function() {
    Kwal.audio.init();
    Kwal.brightness.init();
    Kwal.modal.init();
    Kwal.sd.init();
    Kwal.pattern.init();
    Kwal.colorpicker.init();
    Kwal.colors.init();
    Kwal.ota.init();
    Kwal.status.init();
    Kwal.health.init();
    Kwal.mp3grid.init();
    
    // Health modal: load on open, refresh button
    var healthModal = document.getElementById('health-modal');
    var healthRefresh = document.getElementById('health-refresh');
    if (healthModal) {
      // Load health when modal becomes visible
      var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(m) {
          if (m.attributeName === 'class' && healthModal.classList.contains('open')) {
            Kwal.health.load();
          }
        });
      });
      observer.observe(healthModal, { attributes: true });
    }
    if (healthRefresh) {
      healthRefresh.onclick = function() { Kwal.health.load(); };
    }
    
    // MP3 Grid modal: load on first open
    var mp3gridModal = document.getElementById('mp3grid-modal');
    if (mp3gridModal) {
      var mp3gridObserver = new MutationObserver(function(mutations) {
        mutations.forEach(function(m) {
          if (m.attributeName === 'class' && mp3gridModal.classList.contains('open')) {
            Kwal.mp3grid.load();
          }
        });
      });
      mp3gridObserver.observe(mp3gridModal, { attributes: true });
    }
    
    // Initialize SSE and wire up live update listeners
    
    // New unified state callback - primary source of truth
    Kwal.sse.onState(function(data) {
      // Brightness slider uses sliderPct directly
      if (typeof data.sliderPct === 'number' && typeof data.brightnessMax === 'number' && data.brightnessMax > 0) {
        var loPct = 0;
        var hiPct = 100;
        if (typeof data.brightnessLo === 'number') {
          loPct = Math.round((data.brightnessLo / data.brightnessMax) * 100);
        }
        if (typeof data.brightnessHi === 'number') {
          hiPct = Math.round((data.brightnessHi / data.brightnessMax) * 100);
        }
        Kwal.brightness.updateFromState(data.sliderPct, loPct, hiPct);
      }
      // Audio slider: F9 pattern - sliderPct directly from firmware
      if (typeof data.audioSliderPct === 'number' && typeof data.volumeMax === 'number' && data.volumeMax > 0) {
        var loPct = 0;
        var hiPct = 100;
        if (typeof data.volumeLo === 'number') {
          loPct = Math.round((data.volumeLo / data.volumeMax) * 100);
        }
        if (typeof data.volumeHi === 'number') {
          hiPct = Math.round((data.volumeHi / data.volumeMax) * 100);
        }
        Kwal.audio.updateVolumeFromState(data.audioSliderPct, loPct, hiPct);
      }
      // Pattern/color labels (for status display)
      if (Kwal.status.updateFromState) {
        Kwal.status.updateFromState(data.patternLabel, data.colorLabel);
      }
      // Pattern/color selection (for list highlighting)
      if (data.patternId && Kwal.pattern.setActiveById) {
        Kwal.pattern.setActiveById(data.patternId);
      }
      if (data.colorId && Kwal.colors.setActiveById) {
        Kwal.colors.setActiveById(data.colorId);
      }
      // Fragment info
      if (data.fragment) {
        Kwal.audio.updateFragment(data.fragment.dir, data.fragment.file, data.fragment.score, data.fragment.durationMs, data.fragment.boxName);
        if (Kwal.mp3grid.setSelection) {
          Kwal.mp3grid.setSelection(data.fragment.dir, data.fragment.file, false);
        }
      }
    });
    
    // Legacy callbacks (still fired by firmware during transition)
    Kwal.sse.onFragment(function(dir, file, score) {
      Kwal.audio.updateFragment(dir, file, score, 0);  // No duration in legacy event
    });
    Kwal.sse.onLight(function(patternId, colorId) {
      // Update pattern/color selection indicators without reloading full lists
      if (Kwal.pattern.setActiveById) Kwal.pattern.setActiveById(patternId);
      if (Kwal.colors.setActiveById) Kwal.colors.setActiveById(colorId);
    });
    Kwal.sse.onColors(function(data) {
      // Update full colors list (triggered by delete)
      if (Kwal.colors.updateFromSSE) Kwal.colors.updateFromSSE(data);
    });
    Kwal.sse.onPatterns(function(data) {
      // Update full patterns list (triggered by delete)
      if (Kwal.pattern.updateFromSSE) Kwal.pattern.updateFromSSE(data);
    });
    Kwal.sse.onReconnect(function() {
      // ESP32 rebooted - SSE pushAll() will send patterns, colors, state
      // Only load() what's NOT covered by SSE state event
      if (Kwal.pattern.load) Kwal.pattern.load();
      if (Kwal.colors.load) Kwal.colors.load();
    });
    Kwal.sse.connect();
    
    // Save colors button on main screen
    var saveColorsBtn = document.getElementById('save-colors-btn');
    var saveColorsConfirm = document.getElementById('save-colors-confirm');
    var saveColorsName = document.getElementById('save-colors-name');
    
    if (saveColorsBtn) {
      saveColorsBtn.onclick = function() {
        if (saveColorsName) {
          saveColorsName.value = Kwal.colors.getCurrentLabel();
        }
        Kwal.modal.open('save-colors-modal');
      };
    }
    
    if (saveColorsConfirm && saveColorsName) {
      saveColorsConfirm.onclick = function() {
        var name = saveColorsName.value.trim();
        if (!name) {
          saveColorsName.style.borderColor = '#f88';
          return;
        }
        saveColorsName.style.borderColor = '#444';
        Kwal.colors.saveCurrentColors(name)
          .then(function() {
            Kwal.modal.close('save-colors-modal');
            if (Kwal.status) Kwal.status.load();
          })
          .catch(function(err) {
            console.error('Save failed:', err);
          });
      };
    }
    
    // Save pattern button on main screen
    var savePatternBtn = document.getElementById('save-pattern-btn');
    var savePatternConfirm = document.getElementById('save-pattern-confirm');
    var savePatternName = document.getElementById('save-pattern-name');
    
    if (savePatternBtn) {
      savePatternBtn.onclick = function() {
        if (savePatternName) {
          savePatternName.value = Kwal.pattern.getCurrentLabel();
        }
        Kwal.modal.open('save-pattern-modal');
      };
    }
    
    if (savePatternConfirm && savePatternName) {
      savePatternConfirm.onclick = function() {
        var name = savePatternName.value.trim();
        if (!name) {
          savePatternName.style.borderColor = '#f88';
          return;
        }
        savePatternName.style.borderColor = '#444';
        Kwal.pattern.saveCurrentPattern(name)
          .then(function() {
            Kwal.modal.close('save-pattern-modal');
            if (Kwal.status) Kwal.status.load();
          })
          .catch(function(err) {
            console.error('Save failed:', err);
          });
      };
    }
  });

})();


