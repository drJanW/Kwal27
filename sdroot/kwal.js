/*
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  DO NOT EDIT THIS FILE - COPILOT MEANS YOU                    â•‘
 * â•‘  Source: sdroot/webgui-src/js/*.js                            â•‘
 * â•‘  Build:  cd webgui-src; .\build.ps1                           â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Kwal WebGUI v20260202D - Built 2026-02-02 09:48
 */

// === js/namespace.js ===
/*
 * Kwal - Global namespace
 */
var Kwal = Kwal || {};
window.KWAL_JS_VERSION = '20260202D';  // Injected by build.ps1


// === js/state.js ===
/*
 * Kwal - State module
 * Tracks modified state for colors and patterns
 */
Kwal.state = (function() {
  'use strict';

  var colorsModified = false;
  var patternModified = false;
  
  // Original values to revert to
  var originalColors = { a: null, b: null, id: null };
  var originalPattern = { id: null };

  function setColorsModified(modified, colorA, colorB, id) {
    colorsModified = modified;
    if (modified && colorA && colorB) {
      originalColors = { a: colorA, b: colorB, id: id };
    }
    updateDevModal();
  }

  function setPatternModified(modified, id) {
    patternModified = modified;
    if (modified && id) {
      originalPattern = { id: id };
    }
    updateDevModal();
  }

  function isColorsModified() { return colorsModified; }
  function isPatternModified() { return patternModified; }
  function getOriginalColors() { return originalColors; }
  function getOriginalPattern() { return originalPattern; }

  function clearColorsModified() {
    colorsModified = false;
    originalColors = { a: null, b: null, id: null };
    updateDevModal();
  }

  function clearPatternModified() {
    patternModified = false;
    originalPattern = { id: null };
    updateDevModal();
  }

  function updateDevModal() {
    var saveColorsBtn = document.getElementById('save-colors-btn');
    var savePatternBtn = document.getElementById('save-pattern-btn');
    if (saveColorsBtn) {
      saveColorsBtn.style.display = colorsModified ? 'block' : 'none';
    }
    if (savePatternBtn) {
      savePatternBtn.style.display = patternModified ? 'block' : 'none';
    }
  }

  return {
    setColorsModified: setColorsModified,
    setPatternModified: setPatternModified,
    isColorsModified: isColorsModified,
    isPatternModified: isPatternModified,
    getOriginalColors: getOriginalColors,
    getOriginalPattern: getOriginalPattern,
    clearColorsModified: clearColorsModified,
    clearPatternModified: clearPatternModified
  };
})();


// === js/audio.js ===
/*
 * Kwal - Audio module
 * See docs/glossary_slider_semantics.md for terminology
 * 
 * F9 pattern: Slider shows sliderPct (0-100%) directly.
 * Grey zone left: 0% to loPct
 * Blue zone: loPct to hiPct (usable range)
 * Grey zone right: hiPct to 100%
 * 
 * sliderPct = current volume as percentage of Lo..Hi range
 */
Kwal.audio = (function() {
  'use strict';

  var slider, label, nextBtn, dirEl, fileEl;
  var voteUpBtn, voteDownBtn, voteScoreEl;
  var currentDir = null, currentFile = null;
  var isPlaying = false;
  var playingTimeout = null;
  var loPct = 0;      // Left grey zone boundary (%)
  var hiPct = 100;    // Right grey zone boundary (%)

  function clamp(val) {
    return Math.max(loPct, Math.min(hiPct, val));
  }

  function updateGradient() {
    if (!slider) return;
    var style = 'linear-gradient(to right, ' +
      '#555 0%, #555 ' + loPct + '%, ' +
      '#4682B4 ' + loPct + '%, #4682B4 ' + hiPct + '%, ' +
      '#555 ' + hiPct + '%, #555 100%)';
    slider.style.background = style;
  }

  function setPlayingState(playing) {
    isPlaying = playing;
    if (dirEl) dirEl.classList.toggle('disabled', playing);
    if (fileEl) fileEl.classList.toggle('disabled', playing);
  }

  function init() {
    slider = document.getElementById('volume');
    label = document.getElementById('vol-num');
    nextBtn = document.getElementById('audio-next');
    dirEl = document.getElementById('audio-dir');
    fileEl = document.getElementById('audio-file');
    voteUpBtn = document.getElementById('vote-up');
    voteDownBtn = document.getElementById('vote-down');
    voteScoreEl = document.getElementById('vote-score');
    
    if (slider && label) {
      slider.oninput = function() {
        var val = clamp(parseInt(slider.value, 10));
        slider.value = val;
        label.textContent = val + '%';
      };

      slider.onchange = function() {
        var sliderPct = clamp(parseInt(slider.value, 10));
        slider.value = sliderPct;
        label.textContent = sliderPct + '%';
        // Send sliderPct directly - firmware calculates webShift
        fetch('/setWebAudioLevel?value=' + sliderPct, { method: 'POST' }).catch(function() {});
      };
      
      updateGradient();
    }

    if (nextBtn) {
      nextBtn.onclick = function() {
        nextBtn.disabled = true;
        fetch('/api/audio/next', { method: 'POST' })
          .then(function() {
            setTimeout(function() {
              nextBtn.disabled = false;
            }, 500);
          })
          .catch(function() {
            nextBtn.disabled = false;
          });
      };
    }

    // Click dir: play random from same dir
    if (dirEl) {
      dirEl.onclick = function() {
        if (currentDir !== null && !isPlaying) {
          setPlayingState(true);
          if (playingTimeout) clearTimeout(playingTimeout);
          playingTimeout = setTimeout(function() { setPlayingState(false); }, 32000);
          fetch('/api/audio/play?dir=' + currentDir).catch(function() {
            setPlayingState(false);
          });
        }
      };
    }

    // Click file: replay exact fragment
    if (fileEl) {
      fileEl.onclick = function() {
        if (currentDir !== null && currentFile !== null && !isPlaying) {
          setPlayingState(true);
          if (playingTimeout) clearTimeout(playingTimeout);
          playingTimeout = setTimeout(function() { setPlayingState(false); }, 32000);
          fetch('/api/audio/play?dir=' + currentDir + '&file=' + currentFile).catch(function() {
            setPlayingState(false);
          });
        }
      };
    }

    if (voteUpBtn) {
      voteUpBtn.onclick = function() { vote(3); };
    }
    if (voteDownBtn) {
      voteDownBtn.onclick = function() { vote(-5); };
    }
    
    // No load() - initial state comes from SSE
  }

  function vote(delta) {
    // Optimistic UI - update score immediately, fire-and-forget
    if (voteScoreEl) {
      var current = parseInt(voteScoreEl.textContent, 10);
      if (!isNaN(current)) {
        var newScore = Math.max(1, Math.min(200, current + delta));
        voteScoreEl.textContent = String(newScore);
      }
    }
    // Fire and forget - no blocking
    fetch('/vote?delta=' + delta, { method: 'POST' }).catch(function() {});
  }

  /**
   * Update volume slider from SSE state event
   * @param {number} sliderPct Current volume as percentage (0-100)
   * @param {number} loPercent Left grey zone boundary (%)
   * @param {number} hiPercent Right grey zone boundary (%)
   */
  function updateVolumeFromState(sliderPct, loPercent, hiPercent) {
    if (typeof loPercent === 'number') loPct = loPercent;
    if (typeof hiPercent === 'number') hiPct = hiPercent;
    updateGradient();
    if (slider && label && typeof sliderPct === 'number') {
      var pct = clamp(Math.round(sliderPct));
      slider.value = pct;
      label.textContent = pct + '%';
    }
  }

  /**
   * Update fragment display from SSE event
   * @param {number} dir 
   * @param {number} file 
   * @param {number} score
   * @param {number} durationMs Fragment duration in ms (0 = use default)
   */
  function updateFragment(dir, file, score, durationMs) {
    var isFirstLoad = (currentDir === null);
    var isNewFragment = (dir !== currentDir || file !== currentFile);
    currentDir = dir;
    currentFile = file;
    
    // Only set playing state if this is a NEW fragment during runtime (not first SSE connect)
    if (!isFirstLoad && isNewFragment && dir > 0 && file > 0) {
      setPlayingState(true);
      if (playingTimeout) clearTimeout(playingTimeout);
      // Use durationMs from SSE, fallback to 32s if not available
      var timeout = (typeof durationMs === 'number' && durationMs > 0) ? durationMs + 200 : 32000;
      playingTimeout = setTimeout(function() { setPlayingState(false); }, timeout);
    }
    
    if (dirEl) {
      dirEl.textContent = String(dir).padStart(3, '0');
    }
    if (fileEl) {
      fileEl.textContent = String(file).padStart(3, '0');
    }
    if (typeof score === 'number' && voteScoreEl) {
      voteScoreEl.textContent = score;
    }
  }

  return { init: init, updateVolumeFromState: updateVolumeFromState, updateFragment: updateFragment };
})();


// === js/brightness.js ===
/*
 * Kwal - Brightness module
 * See docs/glossary_slider_semantics.md for terminology
 * 
 * Slider shows sliderPct (0-100%) directly.
 * Grey zone left: 0% to loPct (below minimum)
 * Green zone: loPct to hiPct (usable range)
 * 
 * sliderPct = current brightness as percentage of Lo..Hi range
 */
Kwal.brightness = (function() {
  'use strict';

  var slider, label;
  var loPct = 28;     // Left grey zone boundary
  var hiPct = 100;    // Right grey zone boundary

  function clamp(val) {
    return Math.max(loPct, Math.min(hiPct, val));
  }

  function updateGradient() {
    if (!slider) return;
    // Grey | Green | Grey
    var style = 'linear-gradient(to right, ' +
      '#555 0%, #555 ' + loPct + '%, ' +
      '#4CAF50 ' + loPct + '%, #4CAF50 ' + hiPct + '%, ' +
      '#555 ' + hiPct + '%, #555 100%)';
    slider.style.background = style;
  }

  function init() {
    slider = document.getElementById('brightness');
    label = document.getElementById('bri-num');
    
    if (!slider || !label) return;

    slider.oninput = function() {
      var val = clamp(parseInt(slider.value, 10));
      slider.value = val;
      label.textContent = val + '%';
    };

    slider.onchange = function() {
      var sliderPct = clamp(parseInt(slider.value, 10));
      slider.value = sliderPct;
      label.textContent = sliderPct + '%';
      fetch('/setBrightness?value=' + sliderPct, { method: 'POST' }).catch(function() {});
    };
    
    updateGradient();
  }

  /**
   * Update brightness from SSE state event
   * @param {number} sliderPct Current brightness as percentage (0-100)
   * @param {number} loPercent Left grey zone boundary (%)
   * @param {number} hiPercent Right grey zone boundary (%)
   */
  function updateFromState(sliderPct, loPercent, hiPercent) {
    if (typeof loPercent === 'number') loPct = loPercent;
    if (typeof hiPercent === 'number') hiPct = hiPercent;
    updateGradient();
    if (slider && label && typeof sliderPct === 'number') {
      var pct = clamp(Math.round(sliderPct));
      slider.value = pct;
      label.textContent = pct + '%';
    }
  }

  return { init: init, updateFromState: updateFromState };
})();


// === js/modal.js ===
/*
 * Kwal - Modal module
 */
Kwal.modal = (function() {
  'use strict';

  var backdropLocked = false;

  function init() {
    // Dev button opens dev modal
    var devBtn = document.getElementById('dev-btn');
    if (devBtn) {
      devBtn.onclick = function() { open('dev-modal'); };
    }

    // Buttons with data-open attribute
    var openBtns = document.querySelectorAll('[data-open]');
    for (var i = 0; i < openBtns.length; i++) {
      (function(btn) {
        btn.onclick = function() {
          close('dev-modal');
          var targetId = btn.getAttribute('data-open');
          open(targetId);
          // Trigger load for specific modals
          if (targetId === 'pattern-modal') Kwal.pattern.load();
          if (targetId === 'colors-modal') Kwal.colors.load();
        };
      })(openBtns[i]);
    }

    // Buttons with data-close attribute
    var closeBtns = document.querySelectorAll('[data-close]');
    for (var j = 0; j < closeBtns.length; j++) {
      (function(btn) {
        btn.onclick = function() {
          var modal = btn.closest('.modal');
          if (modal) modal.classList.remove('open');
          // Return to parent modal if specified
          var returnTo = btn.getAttribute('data-return');
          if (returnTo) open(returnTo);
        };
      })(closeBtns[j]);
    }

    // Click on backdrop closes modal (unless locked)
    var modals = document.querySelectorAll('.modal');
    for (var k = 0; k < modals.length; k++) {
      (function(m) {
        m.onclick = function(e) {
          if (e.target === m && !backdropLocked) m.classList.remove('open');
        };
      })(modals[k]);
    }
  }

  function open(id) {
    var el = document.getElementById(id);
    if (el) el.classList.add('open');
  }

  function close(id) {
    var el = document.getElementById(id);
    if (el) el.classList.remove('open');
  }

  function lockBackdrop() { backdropLocked = true; }
  function unlockBackdrop() { backdropLocked = false; }

  return { init: init, open: open, close: close, lockBackdrop: lockBackdrop, unlockBackdrop: unlockBackdrop };
})();


// === js/sd.js ===
/*
 * Kwal - SD module (simple upload to root)
 */
Kwal.sd = (function() {
  'use strict';

  var fileInput, uploadBtn, uploadMsg;

  function init() {
    fileInput = document.getElementById('upload-file');
    uploadBtn = document.getElementById('upload-btn');
    uploadMsg = document.getElementById('upload-msg');

    if (uploadBtn) uploadBtn.onclick = upload;
  }

  function upload() {
    if (!fileInput || !fileInput.files[0]) {
      showMsg('No file selected', true);
      return;
    }

    var file = fileInput.files[0];
    showMsg('Uploading...', false);

    var form = new FormData();
    form.append('file', file);

    fetch('/api/sd/upload', { method: 'POST', body: form })
      .then(function(r) {
        if (!r.ok) throw new Error(r.statusText);
        return r.json();
      })
      .then(function(data) {
        showMsg('OK: ' + (data.path || file.name), false);
        fileInput.value = '';
      })
      .catch(function(err) {
        showMsg('Error: ' + err.message, true);
      });
  }

  function showMsg(text, isError) {
    if (uploadMsg) {
      uploadMsg.textContent = text;
      uploadMsg.className = isError ? 'err' : 'ok';
    }
  }

  return {
    init: init
  };
})();


// === js/pattern.js ===
/*
 * Kwal - Pattern module
 * API: GET /api/patterns, POST /api/patterns/select, POST /api/patterns/preview
 */
Kwal.pattern = (function() {
  'use strict';

  var listEl, activeId, patternsData;
  var editingId = null;
  var originalLabel = null;
  var currentParams = null;
  var previewTimeout = null;
  var expandedId = null;

  // Parameter definitions with limits from old code
  var PARAMS = [
    { key: 'color_cycle_sec',  label: 'Color Cycle (s)',  min: 1,    max: 120, step: 1 },
    { key: 'bright_cycle_sec', label: 'Bright Cycle (s)', min: 1,    max: 120, step: 1 },
    { key: 'min_brightness',   label: 'Min Brightness',   min: 1,    max: 255, step: 1 },
    { key: 'fade_width',       label: 'Fade Width',       min: 1,    max: 400, step: 0.5 },
    { key: 'gradient_speed',   label: 'Gradient Speed',   min: 0.01, max: 1,   step: 0.01 },
    { key: 'center_x',         label: 'Center X',         min: -132, max: 132, step: 0.5 },
    { key: 'center_y',         label: 'Center Y',         min: -132, max: 132, step: 0.5 },
    { key: 'radius',           label: 'Radius',           min: 1,    max: 164, step: 0.5 },
    { key: 'window_width',     label: 'Window Width',     min: 1,    max: 164, step: 0.5 },
    { key: 'radius_osc',       label: 'Radius Osc',       min: 1,    max: 164, step: 0.5 },
    { key: 'x_amp',            label: 'X Amplitude',      min: 1,    max: 116, step: 0.5 },
    { key: 'y_amp',            label: 'Y Amplitude',      min: 1,    max: 116, step: 0.5 },
    { key: 'x_cycle_sec',      label: 'X Cycle (s)',      min: 1,    max: 120, step: 1 },
    { key: 'y_cycle_sec',      label: 'Y Cycle (s)',      min: 1,    max: 120, step: 1 }
  ];

  var nextBtn, prevBtn;

  function init() {
    listEl = document.getElementById('pattern-list');
    nextBtn = document.getElementById('pattern-next');
    prevBtn = document.getElementById('pattern-prev');
    
    if (nextBtn) {
      nextBtn.onclick = function() { navigate('/api/patterns/next'); };
    }
    if (prevBtn) {
      prevBtn.onclick = function() { navigate('/api/patterns/prev'); };
    }
  }

  function navigate(url) {
    if (nextBtn) nextBtn.disabled = true;
    if (prevBtn) prevBtn.disabled = true;
    // Clear modified state - switching patterns discards unsaved edits
    if (Kwal.state) Kwal.state.clearPatternModified();
    editingId = null;
    currentParams = null;
    expandedId = null;
    fetch(url, { method: 'POST' })
      .then(function(r) {
        if (r.ok) {
          load();
          // Status labels come from SSE state event, no need to call load()
        }
      })
      .finally(function() {
        if (nextBtn) nextBtn.disabled = false;
        if (prevBtn) prevBtn.disabled = false;
      });
  }

  function load() {
    if (!listEl) return;

    fetch('/api/patterns')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        activeId = data.active_pattern;
        patternsData = data.patterns || [];
        renderList();
      })
      .catch(function(err) {
        console.error('Pattern load failed:', err);
        listEl.innerHTML = '<p style="color:#f88">Laden mislukt</p>';
      });
  }

  function renderList() {
    listEl.innerHTML = '';
    var canDelete = patternsData.length > 1;
    patternsData.forEach(function(p) {
      var item = document.createElement('div');
      item.className = 'pattern-item' + (p.id === activeId ? ' active' : '');
      
      var header = document.createElement('div');
      header.className = 'pattern-header';
      
      var label = document.createElement('span');
      label.className = 'pattern-label';
      label.textContent = p.label;
      label.onclick = function() { selectPattern(p.id); };
      
      var editBtn = document.createElement('span');
      editBtn.className = 'pattern-edit-btn';
      editBtn.textContent = 'â–¼';
      editBtn.onclick = function(e) { e.stopPropagation(); toggleExpand(p); };
      
      header.appendChild(label);
      header.appendChild(editBtn);
      
      // Delete button (only if more than 1 pattern)
      if (canDelete) {
        var delBtn = document.createElement('button');
        delBtn.className = 'btn-delete';
        delBtn.textContent = 'ðŸ—‘';
        delBtn.title = 'Verwijder';
        delBtn.onclick = function(e) { e.stopPropagation(); deletePattern(p.id, p.label); };
        header.appendChild(delBtn);
      }
      
      item.appendChild(header);
      
      // Expanded slider panel
      if (expandedId === p.id) {
        var panel = createSliderPanel(p);
        item.appendChild(panel);
      }
      
      listEl.appendChild(item);
    });
  }

  function deletePattern(id, label) {
    if (!confirm('Verwijder "' + label + '"?')) return;
    fetch('/api/patterns/delete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) return r.json();
        throw new Error('Delete failed');
      })
      .then(function(data) {
        // Update from response
        activeId = data.active_pattern;
        patternsData = data.patterns || [];
        editingId = null;
        currentParams = null;
        expandedId = null;
        renderList();
        // Status labels come from SSE state event
      })
      .catch(function(err) {
        console.error('Delete pattern failed:', err);
        alert('Verwijderen mislukt');
      });
  }

  function selectPattern(id) {
    fetch('/api/patterns/select', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) {
          activeId = id;
          editingId = null;
          originalLabel = null;
          currentParams = null;
          expandedId = null;
          renderList();
          // Status labels come from SSE state event
          if (Kwal.state) Kwal.state.clearPatternModified();
        }
      })
      .catch(function() {});
  }

  function toggleExpand(pattern) {
    if (expandedId === pattern.id) {
      expandedId = null;
    } else {
      expandedId = pattern.id;
      editingId = pattern.id;
      originalLabel = pattern.label;
      currentParams = JSON.parse(JSON.stringify(pattern.params));
      
      // Store original for revert
      if (Kwal.state && !Kwal.state.isPatternModified()) {
        Kwal.state.setPatternModified(false, pattern.id);
      }
      
      // Select this pattern
      fetch('/api/patterns/select', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: pattern.id })
      }).then(function() {
        activeId = pattern.id;
        // Status labels come from SSE state event
      });
    }
    renderList();
  }

  function createSliderPanel(pattern) {
    var panel = document.createElement('div');
    panel.className = 'pattern-sliders';
    
    var params = currentParams || pattern.params;
    
    PARAMS.forEach(function(def) {
      var row = document.createElement('div');
      row.className = 'slider-row';
      
      var lbl = document.createElement('label');
      lbl.textContent = def.label;
      
      var slider = document.createElement('input');
      slider.type = 'range';
      slider.min = def.min;
      slider.max = def.max;
      slider.step = def.step;
      slider.value = params[def.key] || def.min;
      
      var val = document.createElement('span');
      val.className = 'slider-val';
      val.textContent = slider.value;
      
      slider.oninput = function() {
        val.textContent = slider.value;
        currentParams[def.key] = parseFloat(slider.value);
        schedulePreview();
        
        // Mark as modified
        if (Kwal.state) {
          Kwal.state.setPatternModified(true, editingId);
        }
      };
      
      row.appendChild(lbl);
      row.appendChild(slider);
      row.appendChild(val);
      panel.appendChild(row);
    });
    
    return panel;
  }

  function schedulePreview() {
    if (previewTimeout) clearTimeout(previewTimeout);
    previewTimeout = setTimeout(doPreview, 150);
  }

  function doPreview() {
    if (!currentParams) return;
    fetch('/api/patterns/preview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ params: currentParams })
    });
  }

  // Called from save modal
  function saveCurrentPattern(label) {
    if (!currentParams) return Promise.reject('No params');
    var payload = {
      label: label,
      params: currentParams,
      select: true
    };
    // Only include id if label unchanged (update existing), omit id to create new
    if (label === originalLabel && editingId) {
      payload.id = editingId;
    }
    return fetch('/api/patterns', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
      .then(function(r) { return r.json(); })
      .then(function() {
        if (Kwal.state) Kwal.state.clearPatternModified();
        expandedId = null;
        load(); // Refresh list
      });
  }

  function getCurrentLabel() {
    if (!editingId) return '';
    var p = patternsData.find(function(x) { return x.id === editingId; });
    return p ? p.label : '';
  }

  /**
   * Update active pattern indicator from SSE event (no server call)
   * @param {string} id - Pattern ID
   */
  function setActiveById(id) {
    if (id && id !== activeId) {
      activeId = id;
      renderList();
    }
  }

  /**
   * Update patterns list from SSE event data
   * @param {object} data - {active_pattern, patterns: [...]}
   */
  function updateFromSSE(data) {
    activeId = data.active_pattern;
    patternsData = data.patterns || [];
    editingId = null;
    currentParams = null;
    expandedId = null;
    renderList();
  }

  return {
    init: init,
    load: load,
    saveCurrentPattern: saveCurrentPattern,
    getCurrentLabel: getCurrentLabel,
    setActiveById: setActiveById,
    updateFromSSE: updateFromSSE
  };
})();


// === js/colors.js ===
/*
 * Kwal - Colors module
 * API: GET /api/colors, POST /api/colors/select, POST /api/colors/preview
 */
Kwal.colors = (function() {
  'use strict';

  var listEl, activeId, colorsData;
  var editingId = null;
  var originalLabel = null;
  var editingColor = null; // 'a' or 'b'
  var currentA = null, currentB = null;
  var previewTimeout = null;
  var nextBtn, prevBtn;

  function init() {
    listEl = document.getElementById('colors-list');
    nextBtn = document.getElementById('colors-next');
    prevBtn = document.getElementById('colors-prev');
    
    if (nextBtn) {
      nextBtn.onclick = function() { navigate('/api/colors/next'); };
    }
    if (prevBtn) {
      prevBtn.onclick = function() { navigate('/api/colors/prev'); };
    }
  }

  function navigate(url) {
    if (nextBtn) nextBtn.disabled = true;
    if (prevBtn) prevBtn.disabled = true;
    // Clear modified state - switching colors discards unsaved edits
    if (Kwal.state) Kwal.state.clearColorsModified();
    editingId = null;
    currentA = null;
    currentB = null;
    fetch(url, { method: 'POST' })
      .then(function(r) {
        if (r.ok) {
          load();
          // Status labels come from SSE state event
        }
      })
      .finally(function() {
        if (nextBtn) nextBtn.disabled = false;
        if (prevBtn) prevBtn.disabled = false;
      });
  }

  function load() {
    if (!listEl) return;

    fetch('/api/colors')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        activeId = data.active_color;
        colorsData = data.colors || [];
        renderList();
      })
      .catch(function(err) {
        console.error('Colors load failed:', err);
        listEl.innerHTML = '<p style="color:#f88">Laden mislukt</p>';
      });
  }

  function renderList() {
    listEl.innerHTML = '';
    var canDelete = colorsData.length > 1;
    colorsData.forEach(function(c) {
      var item = document.createElement('div');
      item.className = 'color-item' + (c.id === activeId ? ' active' : '');
      
      // Use current editing values if this is the item being edited
      var displayA = (c.id === editingId && currentA) ? currentA : c.colorA_hex;
      var displayB = (c.id === editingId && currentB) ? currentB : c.colorB_hex;
      
      var swatchA = document.createElement('span');
      swatchA.className = 'color-swatch-box';
      swatchA.style.background = displayA;
      swatchA.onclick = function(e) { e.stopPropagation(); openPicker(c, 'a'); };
      
      var swatchB = document.createElement('span');
      swatchB.className = 'color-swatch-box';
      swatchB.style.background = displayB;
      swatchB.onclick = function(e) { e.stopPropagation(); openPicker(c, 'b'); };
      
      var swatchDiv = document.createElement('div');
      swatchDiv.className = 'color-swatch';
      swatchDiv.appendChild(swatchA);
      swatchDiv.appendChild(swatchB);
      
      var label = document.createElement('span');
      label.className = 'color-label';
      label.textContent = c.label;
      label.onclick = function() { selectColor(c.id); };
      
      item.appendChild(swatchDiv);
      item.appendChild(label);
      
      // Delete button (only if more than 1 color set)
      if (canDelete) {
        var delBtn = document.createElement('button');
        delBtn.className = 'btn-delete';
        delBtn.textContent = 'ðŸ—‘';
        delBtn.title = 'Verwijder';
        delBtn.onclick = function(e) { e.stopPropagation(); deleteColorSet(c.id, c.label); };
        item.appendChild(delBtn);
      }
      
      listEl.appendChild(item);
    });
  }

  function deleteColorSet(id, label) {
    if (!confirm('Verwijder "' + label + '"?')) return;
    fetch('/api/colors/delete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) return r.json();
        throw new Error('Delete failed');
      })
      .then(function(data) {
        // Update from response
        activeId = data.active_color;
        colorsData = data.colors || [];
        renderList();
        // Status labels come from SSE state event
      })
      .catch(function(err) {
        console.error('Delete color failed:', err);
        alert('Verwijderen mislukt');
      });
  }

  function selectColor(id) {
    fetch('/api/colors/select', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: id })
    })
      .then(function(r) {
        if (r.ok) {
          activeId = id;
          editingId = null;
          originalLabel = null;
          currentA = null;
          currentB = null;
          renderList();
          // Status labels come from SSE state event
          if (Kwal.state) Kwal.state.clearColorsModified();
        }
      })
      .catch(function() {});
  }

  var pickerOpen = false;

  function openPicker(colorSet, which) {
    // Lock backdrop FIRST before anything else
    pickerOpen = true;
    if (Kwal.modal.lockBackdrop) Kwal.modal.lockBackdrop();
    
    // First select this color set (only if different)
    if (editingId !== colorSet.id) {
      editingId = colorSet.id;
      originalLabel = colorSet.label;
      currentA = colorSet.colorA_hex;
      currentB = colorSet.colorB_hex;
      
      // Store original for revert
      if (Kwal.state && !Kwal.state.isColorsModified()) {
        Kwal.state.setColorsModified(false, currentA, currentB, editingId);
      }
      
      // Select and display
      fetch('/api/colors/select', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: editingId })
      }).then(function() {
        activeId = editingId;
        renderList();
        // Status labels come from SSE state event
      });
    }
    
    // Create color input
    editingColor = which;
    var picker = document.createElement('input');
    picker.type = 'color';
    picker.value = (which === 'a') ? currentA : currentB;
    picker.style.position = 'absolute';
    picker.style.opacity = '0';
    picker.style.pointerEvents = 'none';
    document.body.appendChild(picker);
    
    picker.oninput = function() {
      if (which === 'a') {
        currentA = picker.value;
      } else {
        currentB = picker.value;
      }
      schedulePreview();
      // Mark as modified
      if (Kwal.state) {
        var orig = Kwal.state.getOriginalColors();
        Kwal.state.setColorsModified(true, orig.a, orig.b, orig.id);
      }
    };
    
    picker.onchange = function() {
      document.body.removeChild(picker);
      renderList();
      pickerOpen = false;
      // Delay unlock to avoid click-through
      setTimeout(function() {
        if (!pickerOpen && Kwal.modal.unlockBackdrop) {
          Kwal.modal.unlockBackdrop();
        }
      }, 200);
    };
    
    picker.click();
  }

  function schedulePreview() {
    if (previewTimeout) clearTimeout(previewTimeout);
    previewTimeout = setTimeout(doPreview, 150);
  }

  function doPreview() {
    if (!currentA || !currentB) return;
    fetch('/api/colors/preview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ colorA_hex: currentA, colorB_hex: currentB })
    });
  }

  // Called from save modal
  function saveCurrentColors(label) {
    if (!currentA || !currentB) return Promise.reject('No colors');
    var payload = {
      label: label,
      colorA_hex: currentA,
      colorB_hex: currentB,
      select: true
    };
    // Only include id if label unchanged (update existing), omit id to create new
    if (label === originalLabel && editingId) {
      payload.id = editingId;
    }
    return fetch('/api/colors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
      .then(function(r) { return r.json(); })
      .then(function() {
        if (Kwal.state) Kwal.state.clearColorsModified();
        load(); // Refresh list
      });
  }

  function getCurrentLabel() {
    if (!editingId) return '';
    var c = colorsData.find(function(x) { return x.id === editingId; });
    return c ? c.label : '';
  }

  /**
   * Update active color indicator from SSE event (no server call)
   * @param {string} id - Color ID
   */
  function setActiveById(id) {
    if (id && id !== activeId) {
      activeId = id;
      renderList();
    }
  }

  /**
   * Update colors list from SSE event data
   * @param {object} data - {active_color, colors: [...]}
   */
  function updateFromSSE(data) {
    activeId = data.active_color;
    colorsData = data.colors || [];
    editingId = null;
    currentA = null;
    currentB = null;
    renderList();
  }

  return {
    init: init,
    load: load,
    saveCurrentColors: saveCurrentColors,
    getCurrentLabel: getCurrentLabel,
    setActiveById: setActiveById,
    updateFromSSE: updateFromSSE
  };
})();


// === js/ota.js ===
/*
 * Kwal - OTA module
 * API: POST /ota/start
 */
Kwal.ota = (function() {
  'use strict';

  var startBtn, status, countdown;

  function init() {
    startBtn = document.getElementById('ota-start');
    status = document.getElementById('ota-status');

    if (startBtn) {
      startBtn.onclick = startOta;
    }
  }

  function startOta() {
    if (startBtn) startBtn.disabled = true;
    showStatus('OTA starten...', false);

    fetch('/ota/start', { method: 'POST' })
      .then(function(r) {
        if (!r.ok) throw new Error(r.statusText);
        return r.text();
      })
      .then(function(msg) {
        showStatus(msg, false);
        startCountdown(300);
      })
      .catch(function(err) {
        showStatus('Error: ' + err.message, true);
        if (startBtn) startBtn.disabled = false;
      });
  }

  function startCountdown(seconds) {
    countdown = seconds;
    showStatus('Waiting for upload... ' + countdown + 's', false);
    var timer = setInterval(function() {
      countdown--;
      if (countdown <= 0) {
        clearInterval(timer);
        showStatus('OTA timeout - refresh page', false);
        if (startBtn) startBtn.disabled = false;
      } else {
        showStatus('Waiting for upload... ' + countdown + 's', false);
      }
    }, 1000);
  }

  function showStatus(msg, isError) {
    if (status) {
      status.textContent = msg;
      status.className = isError ? 'err' : '';
    }
  }

  return { init: init };
})();


// === js/status.js ===
/*
 * Kwal - Status module
 * Shows current active pattern and colors on main screen
 * Labels now come from SSE state event (patternLabel, colorLabel)
 */
Kwal.status = (function() {
  'use strict';

  var patternLabel, colorsLabel;

  function init() {
    patternLabel = document.getElementById('current-pattern');
    colorsLabel = document.getElementById('current-colors');
    // No load() - labels come from SSE state event
  }

  /**
   * Update labels from SSE state event
   * @param {string} pattern - Pattern label
   * @param {string} color - Color label
   */
  function updateFromState(pattern, color) {
    if (patternLabel) {
      patternLabel.textContent = pattern || '-';
    }
    if (colorsLabel) {
      colorsLabel.textContent = color || '-';
    }
  }

  // Keep load() for backward compatibility but it does nothing now
  function load() {}

  return { init: init, load: load, updateFromState: updateFromState };
})();


// === js/health.js ===
/*
 * Kwal - Health module
 * System health status display in DEV modal
 * API: GET /api/health, POST /api/restart
 */
Kwal.health = (function() {
  'use strict';

  // Health bit definitions (must match AlertState::getHealthBits())
  // KRITIEK: Volgorde MOET matchen met enum StatusComponent in AlertState.h!
  var FLAGS = [
    { bit: 0, name: 'SD',       icon: 'ðŸ’¾' },
    { bit: 1, name: 'WiFi',     icon: 'ðŸ“¶' },
    { bit: 2, name: 'RTC',      icon: 'ðŸ•' },
    { bit: 3, name: 'Audio',    icon: 'ðŸ”Š' },
    { bit: 4, name: 'Distance', icon: 'ðŸ“' },
    { bit: 5, name: 'Lux',      icon: 'â˜€ï¸' },
    { bit: 6, name: 'Sensor3',  icon: 'ðŸŒ¡ï¸' },
    { bit: 7, name: 'NTP',      icon: 'â°' },
    { bit: 8, name: 'Weather',  icon: 'ðŸŒ¤ï¸' },
    { bit: 9, name: 'Calendar', icon: 'ðŸ“…' },
    { bit: 10, name: 'TTS',     icon: 'ðŸ—£ï¸' }
  ];

  // Status values for 4-bit fields (must match AlertState.h)
  var STATUS_OK = 0;
  var STATUS_NOTOK = 15;

  var container, restartBtn;

  // Extract 4-bit field from boot status uint64
  // Note: JS handles numbers up to 2^53 safely, uint64 fits
  function getStatusField(bootStatus, index) {
    return (bootStatus / Math.pow(16, index)) & 0xF | 0;
  }

  // Render status icon based on 4-bit value
  function renderStatus(value) {
    if (value === STATUS_OK) return 'âœ…';
    if (value === STATUS_NOTOK) return 'âŒ';
    return 'âŸ³' + value;
  }

  function init() {
    container = document.getElementById('health-content');
    restartBtn = document.getElementById('restart-btn');
    if (restartBtn) {
      restartBtn.onclick = doRestart;
    }
  }

  function load() {
    if (!container) return;
    container.innerHTML = '<em>Loading...</em>';

    fetch('/api/health')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        render(data);
      })
      .catch(function(err) {
        container.innerHTML = '<em>Error: ' + err.message + '</em>';
      });
  }

  function render(data) {
    if (!container) return;

    var html = '<table class="health-table">';

    // Version info
    html += '<tr><th colspan="2">Versions</th></tr>';
    html += '<tr><td>Firmware</td><td>' + (data.firmware || '?') + '</td></tr>';
    html += '<tr><td>WebGUI</td><td>' + (window.KWAL_JS_VERSION || '?') + '</td></tr>';

    // Timer count
    html += '<tr><th colspan="2">Resources</th></tr>';
    html += '<tr><td>Timers</td><td>' + data.timers + '/' + data.maxTimers + '</td></tr>';

    // Flags with boot status (use boot field if available, fallback to health bits)
    html += '<tr><th colspan="2">Hardware & Status</th></tr>';
    var healthBits = data.health || 0;
    var bootStatus = data.boot || 0;
    var absentBits = data.absent || 0;
    var useBoot = (data.boot !== undefined);
    
    for (var i = 0; i < FLAGS.length; i++) {
      var f = FLAGS[i];
      var status;
      // Check if hardware is absent (not present per HWconfig)
      if (absentBits & (1 << f.bit)) {
        status = 'â€”';
      } else if (useBoot) {
        var value = getStatusField(bootStatus, f.bit);
        status = renderStatus(value);
      } else {
        var ok = (healthBits & (1 << f.bit)) !== 0;
        status = ok ? 'âœ…' : 'âŒ';
      }
      html += '<tr><td>' + f.icon + ' ' + f.name + '</td><td>' + status + '</td></tr>';
    }

    html += '</table>';
    container.innerHTML = html;
  }

  function doRestart() {
    if (restartBtn) restartBtn.disabled = true;
    fetch('/api/restart', { method: 'POST' })
      .then(function(r) {
        if (!r.ok) throw new Error(r.statusText);
        if (restartBtn) restartBtn.textContent = 'Restarting...';
        setTimeout(function() { location.reload(); }, 5000);
      })
      .catch(function(err) {
        alert('Restart failed: ' + err.message);
        if (restartBtn) restartBtn.disabled = false;
      });
  }

  return { init: init, load: load };
})();


// === js/log.js ===
(function() {
  'use strict';
  
  function fetchLog() {
    var pre = document.getElementById('log-content');
    if (!pre) return;
    
    fetch('/log')
      .then(function(r) { return r.text(); })
      .then(function(txt) { 
        pre.textContent = txt || '(empty)';
        pre.scrollTop = pre.scrollHeight;
      })
      .catch(function(e) { pre.textContent = 'Error: ' + e; });
  }
  
  function clearLog() {
    fetch('/log/clear')
      .then(function() { fetchLog(); })
      .catch(function(e) { console.error('Clear failed:', e); });
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    var refreshBtn = document.getElementById('log-refresh');
    var clearBtn = document.getElementById('log-clear');
    
    if (refreshBtn) refreshBtn.onclick = fetchLog;
    if (clearBtn) clearBtn.onclick = clearLog;
    
    // Auto-fetch when modal opens
    var logModal = document.getElementById('log-modal');
    if (logModal) {
      var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(m) {
          if (m.attributeName === 'class' && 
              logModal.classList.contains('open')) {
            fetchLog();
          }
        });
      });
      observer.observe(logModal, { attributes: true });
    }
  });
})();


// === js/sse.js ===
/**
 * sse.js - Server-Sent Events for live updates
 * Events: state, patterns, colors (legacy: fragment, light)
 */
(function() {
    'use strict';
    
    let eventSource = null;
    let reconnectTimer = null;
    let hasConnectedOnce = false;
    const RECONNECT_POLL_MS = 2000;
    
    // Callbacks registered by other modules
    const listeners = {
        state: [],      // New unified state event
        fragment: [],   // Legacy (still fired by firmware)
        light: [],      // Legacy (still fired by firmware)
        colors: [],
        patterns: [],
        reconnect: []   // Called on reconnect to refresh state
    };
    
    function connect() {
        if (eventSource) {
            eventSource.close();
        }
        
        eventSource = new EventSource('/api/events');
        
        eventSource.onopen = function() {
            console.log('[SSE] Connected');
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            // On reconnect (not first connect), refresh all data
            // ESP32 may have rebooted with new random pattern/color
            if (hasConnectedOnce) {
                console.log('[SSE] Reconnected - refreshing state');
                listeners.reconnect.forEach(function(cb) { cb(); });
            }
            hasConnectedOnce = true;
        };
        
        eventSource.onerror = function(e) {
            console.warn('[SSE] Error, reconnecting...', e);
            eventSource.close();
            eventSource = null;
            scheduleReconnect();
        };
        
        // Unified state event (new)
        eventSource.addEventListener('state', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] state:', data);
                listeners.state.forEach(cb => cb(data));
            } catch (err) {
                console.error('[SSE] state parse error:', err);
            }
        });
        
        // Fragment change event (legacy)
        eventSource.addEventListener('fragment', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] fragment:', data);
                listeners.fragment.forEach(cb => cb(data.dir, data.file, data.score));
            } catch (err) {
                console.error('[SSE] fragment parse error:', err);
            }
        });
        
        // Light change event (pattern/color)
        eventSource.addEventListener('light', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] light:', data);
                listeners.light.forEach(cb => cb(data.pattern, data.color));
            } catch (err) {
                console.error('[SSE] light parse error:', err);
            }
        });
        
        // Colors list change event
        eventSource.addEventListener('colors', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] colors:', data);
                listeners.colors.forEach(cb => cb(data));
            } catch (err) {
                console.error('[SSE] colors parse error:', err);
            }
        });
        
        // Patterns list change event
        eventSource.addEventListener('patterns', function(e) {
            try {
                const data = JSON.parse(e.data);
                console.log('[SSE] patterns:', data);
                listeners.patterns.forEach(cb => cb(data));
            } catch (err) {
                console.error('[SSE] patterns parse error:', err);
            }
        });
    }
    
    function scheduleReconnect() {
        if (reconnectTimer) return;
        console.log('[SSE] Starting reconnect polling...');
        reconnectTimer = setInterval(async function() {
            try {
                const response = await fetch('/api/health');
                if (response.ok) {
                    console.log('[SSE] Device back online, reloading page...');
                    clearInterval(reconnectTimer);
                    reconnectTimer = null;
                    location.reload();
                }
            } catch (e) {
                // Still offline, keep polling
            }
        }, RECONNECT_POLL_MS);
    }
    
    function disconnect() {
        if (reconnectTimer) {
            clearInterval(reconnectTimer);
            reconnectTimer = null;
        }
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
    }
    
    /**
     * Register callback for fragment changes
     * @param {function(dir: number, file: number): void} cb
     */
    function onFragment(cb) {
        if (typeof cb === 'function') {
            listeners.fragment.push(cb);
        }
    }
    
    /**
     * Register callback for light changes
     * @param {function(patternId: string, colorId: string): void} cb
     */
    function onLight(cb) {
        if (typeof cb === 'function') {
            listeners.light.push(cb);
        }
    }
    
    /**
     * Register callback for colors list changes
     * @param {function(data: object): void} cb
     */
    function onColors(cb) {
        if (typeof cb === 'function') {
            listeners.colors.push(cb);
        }
    }
    
    /**
     * Register callback for patterns list changes
     * @param {function(data: object): void} cb
     */
    function onPatterns(cb) {
        if (typeof cb === 'function') {
            listeners.patterns.push(cb);
        }
    }
    
    /**
     * Register callback for reconnect (to refresh state after ESP32 reboot)
     * @param {function(): void} cb
     */
    function onReconnect(cb) {
        if (typeof cb === 'function') {
            listeners.reconnect.push(cb);
        }
    }
    
    /**
     * Register callback for unified state event
     * @param {function(data: {brightness, audioLevel, patternId, patternLabel, colorId, colorLabel, fragment}): void} cb
     */
    function onState(cb) {
        if (typeof cb === 'function') {
            listeners.state.push(cb);
        }
    }
    
    // Export
    Kwal.sse = {
        connect: connect,
        disconnect: disconnect,
        onState: onState,
        onFragment: onFragment,
        onLight: onLight,
        onColors: onColors,
        onPatterns: onPatterns,
        onReconnect: onReconnect
    };
})();


// === js/main.js ===
/*
 * Kwal WebGUI v1214C - Modular
 * Main entry point
 */
(function() {
  'use strict';

  document.addEventListener('DOMContentLoaded', function() {
    Kwal.audio.init();
    Kwal.brightness.init();
    Kwal.modal.init();
    Kwal.sd.init();
    Kwal.pattern.init();
    Kwal.colors.init();
    Kwal.ota.init();
    Kwal.status.init();
    Kwal.health.init();
    
    // Health modal: load on open, refresh button
    var healthModal = document.getElementById('health-modal');
    var healthRefresh = document.getElementById('health-refresh');
    if (healthModal) {
      // Load health when modal becomes visible
      var observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(m) {
          if (m.attributeName === 'class' && healthModal.classList.contains('open')) {
            Kwal.health.load();
          }
        });
      });
      observer.observe(healthModal, { attributes: true });
    }
    if (healthRefresh) {
      healthRefresh.onclick = function() { Kwal.health.load(); };
    }
    
    // Initialize SSE and wire up live update listeners
    
    // New unified state callback - primary source of truth
    Kwal.sse.onState(function(data) {
      // Brightness slider uses sliderPct directly
      if (typeof data.sliderPct === 'number' && typeof data.brightnessMax === 'number' && data.brightnessMax > 0) {
        var loPct = 0;
        var hiPct = 100;
        if (typeof data.brightnessLo === 'number') {
          loPct = Math.round((data.brightnessLo / data.brightnessMax) * 100);
        }
        if (typeof data.brightnessHi === 'number') {
          hiPct = Math.round((data.brightnessHi / data.brightnessMax) * 100);
        }
        Kwal.brightness.updateFromState(data.sliderPct, loPct, hiPct);
      }
      // Audio slider: F9 pattern - sliderPct directly from firmware
      if (typeof data.audioSliderPct === 'number' && typeof data.volumeMax === 'number' && data.volumeMax > 0) {
        var loPct = 0;
        var hiPct = 100;
        if (typeof data.volumeLo === 'number') {
          loPct = Math.round((data.volumeLo / data.volumeMax) * 100);
        }
        if (typeof data.volumeHi === 'number') {
          hiPct = Math.round((data.volumeHi / data.volumeMax) * 100);
        }
        Kwal.audio.updateVolumeFromState(data.audioSliderPct, loPct, hiPct);
      }
      // Pattern/color labels (for status display)
      if (Kwal.status.updateFromState) {
        Kwal.status.updateFromState(data.patternLabel, data.colorLabel);
      }
      // Pattern/color selection (for list highlighting)
      if (data.patternId && Kwal.pattern.setActiveById) {
        Kwal.pattern.setActiveById(data.patternId);
      }
      if (data.colorId && Kwal.colors.setActiveById) {
        Kwal.colors.setActiveById(data.colorId);
      }
      // Fragment info
      if (data.fragment) {
        Kwal.audio.updateFragment(data.fragment.dir, data.fragment.file, data.fragment.score, data.fragment.durationMs);
      }
    });
    
    // Legacy callbacks (still fired by firmware during transition)
    Kwal.sse.onFragment(function(dir, file, score) {
      Kwal.audio.updateFragment(dir, file, score, 0);  // No duration in legacy event
    });
    Kwal.sse.onLight(function(patternId, colorId) {
      // Update pattern/color selection indicators without reloading full lists
      if (Kwal.pattern.setActiveById) Kwal.pattern.setActiveById(patternId);
      if (Kwal.colors.setActiveById) Kwal.colors.setActiveById(colorId);
    });
    Kwal.sse.onColors(function(data) {
      // Update full colors list (triggered by delete)
      if (Kwal.colors.updateFromSSE) Kwal.colors.updateFromSSE(data);
    });
    Kwal.sse.onPatterns(function(data) {
      // Update full patterns list (triggered by delete)
      if (Kwal.pattern.updateFromSSE) Kwal.pattern.updateFromSSE(data);
    });
    Kwal.sse.onReconnect(function() {
      // ESP32 rebooted - SSE pushAll() will send patterns, colors, state
      // Only load() what's NOT covered by SSE state event
      if (Kwal.pattern.load) Kwal.pattern.load();
      if (Kwal.colors.load) Kwal.colors.load();
    });
    Kwal.sse.connect();
    
    // Save colors button on main screen
    var saveColorsBtn = document.getElementById('save-colors-btn');
    var saveColorsConfirm = document.getElementById('save-colors-confirm');
    var saveColorsName = document.getElementById('save-colors-name');
    
    if (saveColorsBtn) {
      saveColorsBtn.onclick = function() {
        if (saveColorsName) {
          saveColorsName.value = Kwal.colors.getCurrentLabel();
        }
        Kwal.modal.open('save-colors-modal');
      };
    }
    
    if (saveColorsConfirm && saveColorsName) {
      saveColorsConfirm.onclick = function() {
        var name = saveColorsName.value.trim();
        if (!name) {
          saveColorsName.style.borderColor = '#f88';
          return;
        }
        saveColorsName.style.borderColor = '#444';
        Kwal.colors.saveCurrentColors(name)
          .then(function() {
            Kwal.modal.close('save-colors-modal');
            if (Kwal.status) Kwal.status.load();
          })
          .catch(function(err) {
            console.error('Save failed:', err);
          });
      };
    }
    
    // Save pattern button on main screen
    var savePatternBtn = document.getElementById('save-pattern-btn');
    var savePatternConfirm = document.getElementById('save-pattern-confirm');
    var savePatternName = document.getElementById('save-pattern-name');
    
    if (savePatternBtn) {
      savePatternBtn.onclick = function() {
        if (savePatternName) {
          savePatternName.value = Kwal.pattern.getCurrentLabel();
        }
        Kwal.modal.open('save-pattern-modal');
      };
    }
    
    if (savePatternConfirm && savePatternName) {
      savePatternConfirm.onclick = function() {
        var name = savePatternName.value.trim();
        if (!name) {
          savePatternName.style.borderColor = '#f88';
          return;
        }
        savePatternName.style.borderColor = '#444';
        Kwal.pattern.saveCurrentPattern(name)
          .then(function() {
            Kwal.modal.close('save-pattern-modal');
            if (Kwal.status) Kwal.status.load();
          })
          .catch(function(err) {
            console.error('Save failed:', err);
          });
      };
    }
  });

})();


