wifimanager.cpp. refactor. does not use timers right. superfluous checking
bootmaster.cpp - refactor, clean
voting.cpp - contains selection of random file?!?
systemboot en bootmaster overlap?dead code?
why is status policy a stub? is refactor needed?

style: bool : isOK is a function because of is - isOk(); ok, Ok, OK is a bool , not a nice name

=== DONE 2026-01-28 ===
✅ SystemBoot.cpp refactored:
   - Wire.begin() success check + hwStatus |= HW_I2C
   - Serial timeout for headless boot
   - systemBootStage1() returns bool
   - Magic numbers → HWconfig.h constants (SERIAL_BAUD, I2C_CLOCK_HZ, HALT_BLINK_MS)
✅ HW_I2C bit added to HWconfig.h (bit 7)
✅ main.cpp updated: logs Stage 1 incomplete in degraded mode
✅ fallback_policy.md: added hwStatus bits mapping table
✅ HWconfig.h: cross-reference to fallback_policy.md

=== DONE 2026-01-27 ===
✅ TimerManager::instance() eliminated - global `timers` now used everywhere
✅ Token support added (identity = callback + token)
✅ Header docs rewritten with STOP box and clear API rules


Sleep je favicon.ico (of favicon.png) naar de hoofdmap, waar index.html staat
een vierkant icoontje van 32x32 pixels of 16x16 pixels

NAS: enable WebDAV in the Dashboard (Settings → Network → Network Services → WebDAV). �
URL format: http://<NAS-IP>:8080/Public/<path> (common WD docs/examples). �
Ports are commonly 8080 (HTTP) / 4443 (HTTPS). 

The real architectural rule (this matters)
Dependency and Injection Rule
Composition Root
All concrete manager objects are constructed only in the composition root (main.cpp or App.cpp).
Exactly one instance per manager class exists.
No other module may construct, delete, or replace managers.
Example: static TimerManager  timerManager; static LightManager  lightManager(timerManager); static AudioManager  audioManager(timerManager);
Injected Reference
An injected reference is the only allowed way for one module to access another manager.
Definition:
The referenced object is constructed in the composition root.
A reference to it is passed explicitly via constructor or begin(X&).
The reference is stored as a member (X&).
The receiving module does not own the object and never deletes or replaces it.
All access is performed through this reference.
Example: class ConductManager { public: ConductManager(LightManager& light) : light(light) {} private: LightManager& light; };
Access Rules
Modules may access other managers only through injected references.
Static accessors (X::instance()), global variables, and extern objects are forbidden.
No module may perform dynamic lookup of managers.
No module may create a manager it does not own.
Allowed: light.playScene();
Forbidden: LightManager::instance().playScene(); extern LightManager light; new LightManager();
Ownership Rules
Ownership is determined solely by construction location.
The composition root owns all managers for the entire program lifetime.
All injected references are guaranteed to outlive their consumers.
Consequences
This rule guarantees:
Deterministic initialization order
Explicit and visible dependencies in headers
No hidden coupling via globals or singletons
Safe refactoring guided by the compiler
No service containers, no wrappers, no indirection layers

