ARCH TODO (status ownership)

1) WiFi status reads: keep using AlertState (done in code), verify no new wrapper reappears.
   - Files to watch: lib/WiFiController/WiFiController.cpp, lib/WiFiController/WiFiController.h, lib/WiFiController/FetchController.cpp, lib/OTAController/OTAController.cpp, lib/ConductManager/WiFi/WiFiBoot.cpp

3) SDController exposes readiness/busy status via controller APIs. Move reads to state layer.
   - Replace SDController::isReady() and SDController::isSDbusy() with state reads.
   - Ensure SDController only sets state, never owns reads.
   - Files: lib/SDController/SDController.h, lib/SDController/SDController.cpp, call sites to update.

4) Audit other *Controller classes for is* or ready/busy accessors that leak status reads.
   - Only controllers should touch hardware and set status; reads should come from State/Context.
   - Target files: lib/*Controller/*.h, lib/*Controller/*.cpp

5) WiFiController has timer callbacks that belong in a WiFiRun layer.
   - cb_checkWiFiStatus, cb_checkWiFiConnection, cb_retryConnect own timers + AlertState transitions.
   - WiFiController should be hardware API only: connect(), disconnect(), isConnected(), getIP().
   - Timer orchestration, retry logic, and the consecutive-failure counter move to WiFiRun.
   - Files: lib/WiFiController/WiFiController.cpp â†’ split into lib/RunManager/WiFi/WiFiRun.cpp
   - Risk: touches WiFi boot sequence; USB-only recovery if broken. Do on a calm day.
