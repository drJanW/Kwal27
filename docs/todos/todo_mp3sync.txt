MP3 Sync — NAS to ESP32 SD card
=================================
Source: V:\kwal\sdcard\  (NAS MP3 tree, mirrors SD layout: /001/001.mp3 etc.)
Target: ESP32 via HTTP (default 189, param for 188)
Exclude: dir 000 (words/speak — generated, not synced)

PREREQUISITES
=============
[x] NAS MP3 tree populated: V:\kwal\sdcard\001\ through \126\ with raw MP3 files only
    No binaries (.files, .root_dirs), no CSVs, no web files.

FIRMWARE CHANGES
================

[x] TODO 1: Add /api/sd/list endpoint — DONE (commit 40a439a)
[x] TODO 2: Add /api/sd/delete endpoint — DONE (no index update in handler)
[x] TODO 3: Fix /api/sd/upload to support subdirectories — DONE (query param ?path=)
[x] TODO 4: Version bump — DONE (260217D)


PC-SIDE SCRIPT: sync_mp3.ps1
=============================

[x] TODO 5: Create sync_mp3.ps1 — DONE

Usage:
  .\sync_mp3.ps1           # sync to 189 (HOUT)
  .\sync_mp3.ps1 188       # sync to MARMER
  .\sync_mp3.ps1 -ip 192.168.2.188

Pseudo-code:

  param lastOctet = 189, ip = ""
  if ip == "" → ip = "192.168.2.$lastOctet"
  nasRoot = "V:\kwal\sdcard"

  # Phase 1: Scan NAS
  nasDirs = {}   # dirNum → {filename → size}
  for each subdir in nasRoot matching /^\d{3}$/:
    skip if dirNum == 0
    for each .mp3 file in subdir:
      nasDirs[dirNum][filename] = filesize

  # Phase 2: Scan ESP32
  espDirs = {}
  # Get list of all possible dirs (1..max NAS dir)
  for each dirNum in nasDirs.keys:
    response = GET http://{ip}/api/sd/list?path=/{dirNum:03d}
    espDirs[dirNum] = parse response → {filename → size}

  # Also check ESP32 for dirs NOT on NAS (to detect deletions)
  # Get highest dir from /api/audio/grid
  response = GET http://{ip}/api/audio/grid
  espHighest = response.highest
  for dirNum 1..espHighest not already in espDirs:
    response = GET http://{ip}/api/sd/list?path=/{dirNum:03d}
    if response has files:
      espDirs[dirNum] = parse response

  # Phase 3: Compare and build action list
  toUpload = []    # {dirNum, filename, nasPath}
  toDelete = []    # {sdPath}

  for each dirNum in union(nasDirs.keys, espDirs.keys):
    nasFiles = nasDirs[dirNum] or empty
    espFiles = espDirs[dirNum] or empty

    # Files on NAS but not on ESP (or different size) → upload
    for filename in nasFiles:
      if filename not in espFiles or nasFiles[filename] != espFiles[filename]:
        toUpload.add(dirNum, filename)

    # Files on ESP but not on NAS → delete
    for filename in espFiles:
      if filename not in nasFiles:
        toDelete.add("/{dirNum:03d}/{filename}")

  # Phase 4: Confirm
  print "Upload: {toUpload.count} files"
  print "Delete: {toDelete.count} files"
  if toUpload.count == 0 and toDelete.count == 0:
    print "Already in sync."
    exit

  prompt "Continue? [Y/n]"

  # Phase 5: Execute deletions
  for each path in toDelete:
    POST http://{ip}/api/sd/delete?path={path}
    print result

  # Phase 6: Execute uploads
  for each (dirNum, filename) in toUpload:
    nasPath = "{nasRoot}\{dirNum:03d}\{filename}"
    POST http://{ip}/api/sd/upload
      form fields: file=@{nasPath}, path=/{dirNum:03d}
    print result

  # Phase 7: Reindex changed dirs (vote-safe)
  changedDirs = unique dir numbers from toUpload + toDelete
  for each dirNum in changedDirs:
    POST http://{ip}/api/sd/syncdir?dir={dirNum}
    # syncdir preserves existing votes, sets score=100 for new files

  # Phase 8: Summary
  print "Done: {uploaded} uploaded, {deleted} deleted, {changedDirs.count} dirs reindexed"


EMPTY DIR HANDLING
==================
- If all files in an ESP32 dir are deleted (dir existed on ESP but not on NAS):
  the dir folder remains but is empty → rebuildIndex will give it fileCount=0
  No need to rmdir — harmless empty folder.

- If NAS has a dir that doesn't exist on ESP32:
  SD.mkdir is called by the upload endpoint when path=/{dirNum:03d} doesn't exist yet.


VOTING SCORE PRESERVATION
==========================
Votes MUST survive sync. Here's how they're stored:

  FileEntry { uint16_t sizeKb; uint8_t score; uint8_t pad; }  (4 bytes per file)
  DirEntry  { uint8_t fileCount; uint16_t totalScore; }       (3 bytes per dir, padded to 4)

  Per-dir /.files  = array of FileEntry[SD_MAX_FILES_PER_SUBDIR]
                     score field = voting score (default 100, modified by votes)
  .root_dirs       = array of DirEntry[SD_MAX_DIRS]
                     totalScore = sum of all file scores in that dir

rebuildIndex() behavior:
  - If /.files exists and is valid size → PRESERVES it (reads scores, recalcs DirEntry)
  - If /.files missing or corrupt      → calls scanDirectory() which sets score=100 for all

So the sync strategy is:

  For EXISTING dirs (files changed):
    DO NOT delete /.files. Instead:
    - Delete removed MP3 files
    - Upload new MP3 files
    - For files that changed size: upload overwrites the MP3 but /.files still has old score
    - After all file changes: call scanDirectory() only for dirs that had NEW files added
      (new files need a FileEntry with score=100)
    - Better: use a smarter rebuild that preserves existing scores and only adds new entries

  For NEW dirs (dir didn't exist on ESP32):
    - Upload all MP3 files → scanDirectory() creates /.files with score=100 for all
    - This is fine — no votes to preserve.

  For DELETED dirs (dir existed on ESP but not on NAS):
    - Delete all MP3 files
    - Delete /.files index
    - .root_dirs entry becomes fileCount=0 after rebuild
    - Votes are lost — acceptable since the dir is gone.

[x] TODO 6: Add /api/sd/syncdir endpoint — DONE
  SDController::syncDirectory() preserves existing votes.
  SDBoot::requestSyncDir() defers to timer callback.
  POST /api/sd/syncdir?dir=126 → "accepted" → timer → syncDirectory()
  Tested: score=42 survives syncdir. New files get score=100.

ALTERNATIVE (simpler, script-side):
  Instead of a new endpoint, the script can:
    1. Before uploading, GET /api/sd/file?path=/NNN/.files (binary, 400 bytes)
       → save as backup
    2. Do all file uploads/deletes for that dir
    3. POST /api/sd/rebuild (rebuilds everything with scanDirectory for changed dirs)
    4. For dirs that had existing /.files:
       → read old backup, merge scores into new /.files, re-upload /.files
  This is fragile. The firmware endpoint (TODO 6) is cleaner.

RECOMMENDED APPROACH:
  After sync completes:
    - For dirs that are NEW → normal scanDirectory (score=100)
    - For dirs that CHANGED → syncdir endpoint preserves scores
    - For dirs that were DELETED → nothing to preserve
    - Then call updateHighestDirNum() once

  Script sends:
    POST /api/sd/syncdir?dir=108  (for each changed or new dir)
    POST /api/sd/rebuild          (only if needed for .root_dirs consistency)
  Or better: syncdir already updates .root_dirs for that dir, so no full rebuild needed.


NOTES
=====
- Audio should be paused during sync to avoid SD contention.
  Script could call /api/audio/pause before starting (if endpoint exists).

- Expected throughput: ~2-4 MB/s over WiFi. 20 dirs × 40 files × 100KB = ~80MB → ~30s.
