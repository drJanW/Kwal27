===========================================================
AUDIOPLUS ‚Äî Web Audio Control
Feature: temporary web audio settings with expiry
Status:  PLAN (no code yet)
Date:    2026-02-26
===========================================================

GOAL
----
Add 4 WebGUI controls to temporarily adjust audio behavior:
  1. Speak frequency   ‚Äî web-set minSaytimeIntervalMs / maxSaytimeIntervalMs
  2. Fragment frequency ‚Äî web-set minAudioIntervalMs / maxAudioIntervalMs
  3. Silence toggle     ‚Äî suppress all audio output
  4. Duration           ‚Äî how long ALL web audio settings last before auto-reset

Unified expiry: volume slider, interval sliders, and silence toggle
all share one "Geldig" timer. ANY web audio change resets the countdown.
After the duration expires, everything returns to Globals defaults:
  - Volume ‚Üí webMultiplier = 1.0 (calendar/shift-based volume resumes)
  - Intervals ‚Üí Globals min/max values
  - Silence ‚Üí off
No persistent state, no SD writes, no config changes.
Default expiry duration: 13 hours (Globals::defaultWebExpiryMs).

===========================================================
DESIGN
===========================================================

LAYER MAP
---------
  WebGUI (JS)
    ‚îÇ  fetch("/api/audio/intervals?speak=..&frag=..&dur=30")
    ‚îÇ  fetch("/api/audio/level?value=75")        ‚Üê existing volume route
    ‚îÇ  fetch("/api/audio/silence?active=1")      ‚Üê instant toggle
    ‚ñº
  AudioRoutes / existing volume route (WebInterfaceController)
    ‚îÇ  validate params, call RunManager::requestSetAudioIntervals(...)
    ‚îÇ  existing volume route also arms shared expiry timer
    ‚îÇ  silence route also arms shared expiry timer
    ‚ñº
  RunManager (Run layer)
    ‚îÇ  store pending values in namespace statics
    ‚îÇ  timers.cancel(cb_applyAudioIntervals) + create(1, 1, cb_apply...)
    ‚îÇ  ALL web audio routes arm/reset the shared expiry timer
    ‚ñº
  cb_applyAudioIntervals (Run layer, deferred from web context)
    ‚îÇ  copy pending ‚Üí active state
    ‚îÇ  arm expiry timer: cancel + create(durationMs, 1, cb_clearWebAudio)
    ‚îÇ  if silence: PlayAudioFragment::stop(0) + PlaySentence::stop()
    ‚îÇ  reschedule cb_sayTime + cb_playFragment with new ranges
    ‚ñº
  cb_clearWebAudio (Run layer, fires after Geldig duration)
    ‚îÇ  reset: webMultiplier = 1.0, clear intervals, silence = off
    ‚îÇ  reschedule cb_sayTime + cb_playFragment with Globals defaults
    ‚îÇ  trigger SSE push (sliders snap back to defaults)
    ‚ñº
  AudioPolicy (Policy layer) ‚Äî NEW helpers
    ‚îÇ  effectiveSpeakMin/Max()  ‚Äî returns web value or Globals default
    ‚îÇ  effectiveFragmentMin/Max() ‚Äî returns web value or Globals default
    ‚îÇ  isWebSilenceActive()    ‚Äî pure getter, no side effects
    ‚îÇ  setWebSilence(bool)     ‚Äî called only from Run layer
    ‚îÇ  setWebSpeakRange(min, max) / clearWebSpeakRange()
    ‚îÇ  setWebFragmentRange(min, max) / clearWebFragmentRange()
    ‚ñº
  Existing flow unchanged:
    cb_sayTime   ‚Üí requestSayTime ‚Üí AudioPolicy::requestSentence
    cb_playFragment ‚Üí requestPlayFragment ‚Üí AlertState::canPlayFragment
                                          ‚Üí AudioPolicy::requestFragment

SILENCE GATING
--------------
  Option A: Add isWebSilenceActive() check to AlertState::canPlayFragment()
            and SpeakPolicy::canSpeak().
            Pro: zero changes to cb_sayTime/cb_playFragment.
            Con: timers keep firing and silently get rejected.

  Option B: Check in cb_sayTime/cb_playFragment before calling request*.
            Pro: avoids unnecessary request overhead.
            Con: policy logic leaks into Run layer.

  ‚Üí RECOMMENDED: Option A (pure policy gate). The timer overhead is
    negligible (fires once per 6-145 min). This keeps Run layer clean
    and silence works for ALL audio paths, not just timer-driven ones.

  Implementation:
    AlertState::canPlayFragment():
      return isStatusOK(SD) && isStatusOK(AUDIO) && isStatusOK(CALENDAR)
             && !isSyncMode() && !AudioPolicy::isWebSilenceActive();

    SpeakPolicy::canSpeak(SpeakRequest req):       // ‚Üê signature change
      if (isSentencePlaying()) return false;
      if (AudioPolicy::isWebSilenceActive()
          && !isHealthAlert(req)) return false;   // ‚Üê NEW: *_FAIL exempt
      return true;

    // Helper (in SpeakPolicy or SpeakRun):
    bool isHealthAlert(SpeakRequest req) {
        return req <= SpeakRequest::CALENDAR_FAIL;  // all *_FAIL enums are first
    }

WEB INTERVALS
-------------
  Policy layer owns the "what interval should we use?" question.
  Run layer asks Policy and uses the answer.

  AudioPolicy (new functions):
    void setWebSpeakRange(uint32_t minMs, uint32_t maxMs);
    void clearWebSpeakRange();
    uint32_t effectiveSpeakMin();  // returns web value or Globals default
    uint32_t effectiveSpeakMax();  // returns web value or Globals default
    void setWebFragmentRange(uint32_t minMs, uint32_t maxMs);
    void clearWebFragmentRange();
    uint32_t effectiveFragmentMin();
    uint32_t effectiveFragmentMax();

  Storage: namespace statics inside AudioPolicy.cpp (like themeBox state).
  No side effects, pure getters/setters.

  Run layer changes (cb_sayTime, cb_playFragment):
    Replace Globals::minSaytimeIntervalMs with AudioPolicy::effectiveSpeakMin()
    Replace Globals::maxSaytimeIntervalMs with AudioPolicy::effectiveSpeakMax()
    Replace Globals::minAudioIntervalMs with AudioPolicy::effectiveFragmentMin()
    Replace Globals::maxAudioIntervalMs with AudioPolicy::effectiveFragmentMax()

  Note: cb_playFragment already has a themeBox path (singleDir ranges).
  The effective helpers must respect that: if themeBox is web-single-dir AND
  web range is active, web range wins (it's explicitly user-requested).

DURATION / AUTO-RESET (unified for ALL web audio settings)
----------------------------------------------------------
  One shared expiry timer: cb_clearWebAudio
  Armed by ANY web audio change: intervals, volume, or silence.

  Stored duration: RunManager namespace static `webExpiryMs`
    - Initialized to Globals::defaultWebExpiryMs (13 hours)
    - Updated by interval route's `dur` param
    - Used unchanged by volume/silence routes (they don't send dur)

  On expiry fire (cb_clearWebAudio):
    AudioPolicy::clearWebSpeakRange()
    AudioPolicy::clearWebFragmentRange()
    AudioPolicy::setWebSilence(false)
    setVolumeWebMultiplier(1.0f)        ‚Üê NEW: reset volume to default
    Reschedule cb_sayTime + cb_playFragment with normal Globals ranges
    Trigger SSE push (all sliders snap back to defaults)

  If user sends new request while one is active:
    cancel(cb_clearWebAudio) + create(dur, 1, cb_clearWebAudio).
    New values + new duration take effect immediately.

  Volume route arming:
    requestSetAudioLevel() already sets webMultiplier.
    Now also: cancel + create expiry timer with webExpiryMs.

  Silence route arming:
    requestSetSilence() sets silence flag.
    Also: cancel + create expiry timer with webExpiryMs.

  Timer convention (per codebase):
    - Self-reschedule inside own cb_ with varying interval ‚Üí restart()
    - External arming from request handler or other cb_ ‚Üí cancel() + create()
    - First arm at boot                                  ‚Üí create()

===========================================================
FILE CHANGE LIST
===========================================================

FIRMWARE (version bump required before any edit)
------------------------------------------------
  Globals.h                              ‚Äî version bump + defaultWebExpiryMs = HOURS(13)
  AudioPolicy.h                          ‚Äî add 8 new function declarations
  AudioPolicy.cpp                        ‚Äî add web interval/silence state + getters/setters
  AlertState.cpp                         ‚Äî add isWebSilenceActive() check in canPlayFragment()
  SpeakPolicy.cpp                        ‚Äî add isWebSilenceActive() check in canSpeak()
  RunManager.h                           ‚Äî add requestSetAudioIntervals() declaration
  RunManager.cpp                         ‚Äî add request handler + cb_apply/cb_clearWebAudio
                                           + use effective*() in cb_sayTime/cb_playFragment/cb_sayRTCtemperature
                                           + requestSetAudioLevel also arms shared expiry timer
                                           + add requestSetSilence + cb for silence route with expiry
  AudioRoutes.h                          ‚Äî add routeSetIntervals declaration
  AudioRoutes.cpp                        ‚Äî add /api/audio/intervals route + validation

WEBGUI (JS version bump in build.ps1 before any edit)
-----------------------------------------------------
  sdroot/webgui-src/js/audio.js          ‚Äî add interval/silence controls + debounce logic
  sdroot/index.html                      ‚Äî add 3 slider rows + silence toggle + <hr> to audio panel
  sdroot/styles.css                      ‚Äî styling for mute button + <hr> separator

===========================================================
PSEUDOCODE (corrected, per layer)
===========================================================

--- AudioPolicy.cpp (Policy layer, no side effects) ---

namespace {
  bool    webSilence = false;
  bool    webSpeakActive = false;
  uint32_t webSpeakMin = 0;
  uint32_t webSpeakMax = 0;
  bool    webFragActive = false;
  uint32_t webFragMin = 0;
  uint32_t webFragMax = 0;
}

bool isWebSilenceActive()          { return webSilence; }
void setWebSilence(bool active)    { webSilence = active; }

void setWebSpeakRange(uint32_t minMs, uint32_t maxMs) {
    webSpeakMin = minMs;
    webSpeakMax = maxVal(minMs, maxMs);  // ensure min <= max
    webSpeakActive = true;
}
void clearWebSpeakRange()          { webSpeakActive = false; }

uint32_t effectiveSpeakMin() {
    return webSpeakActive ? webSpeakMin : Globals::minSaytimeIntervalMs;
}
uint32_t effectiveSpeakMax() {
    return webSpeakActive ? webSpeakMax : Globals::maxSaytimeIntervalMs;
}

void setWebFragmentRange(uint32_t minMs, uint32_t maxMs) {
    webFragMin = minMs;
    webFragMax = maxVal(minMs, maxMs);
    webFragActive = true;
}
void clearWebFragmentRange()       { webFragActive = false; }

uint32_t effectiveFragmentMin() {
    return webFragActive ? webFragMin : Globals::minAudioIntervalMs;
}
uint32_t effectiveFragmentMax() {
    return webFragActive ? webFragMax : Globals::maxAudioIntervalMs;
}


--- AlertState.cpp (Policy gate) ---

bool canPlayFragment() {
    return isStatusOK(SC_SD) && isStatusOK(SC_AUDIO) && isStatusOK(SC_CALENDAR)
           && !isSyncMode()
           && !AudioPolicy::isWebSilenceActive();      // ‚Üê NEW
}


--- SpeakPolicy.cpp (Policy gate) ---

bool canSpeak() {
    if (isSentencePlaying()) return false;
    if (AudioPolicy::isWebSilenceActive()) return false;  // ‚Üê NEW
    return true;
}


--- RunManager.cpp (Run layer) ---

// Shared expiry duration ‚Äî used by ALL web audio routes
namespace {
  uint32_t webExpiryMs = 0;  // init from Globals at boot
}

// Pending state (set by web handler, consumed by cb_)
namespace {
  struct PendingAudioIntervals {
    uint32_t speakMinMs   = 0;
    uint32_t speakMaxMs   = 0;
    uint32_t fragMinMs    = 0;
    uint32_t fragMaxMs    = 0;
    uint32_t durationMs   = 0;
    bool     silence      = false;
    bool     hasSpeakRange = false;
    bool     hasFragRange  = false;
  } pendingIntervals;
}

void cb_applyAudioIntervals() {
    auto& p = pendingIntervals;

    if (p.hasSpeakRange)
        AudioPolicy::setWebSpeakRange(p.speakMinMs, p.speakMaxMs);
    if (p.hasFragRange)
        AudioPolicy::setWebFragmentRange(p.fragMinMs, p.fragMaxMs);
    AudioPolicy::setWebSilence(p.silence);

    // Update stored duration (interval route sends explicit dur)
    webExpiryMs = p.durationMs;

    // Arm expiry timer ‚Äî external arming ‚Üí cancel + create
    timers.cancel(cb_clearWebAudio);
    timers.create(p.durationMs, 1, cb_clearWebAudio);

    if (p.silence) {
        PlayAudioFragment::stop(0);
        PlaySentence::stop();
    }

    // Reschedule speak/fragment timers ‚Äî external arming ‚Üí cancel + create
    timers.cancel(cb_sayTime);
    timers.create(
        random(AudioPolicy::effectiveSpeakMin(),
               AudioPolicy::effectiveSpeakMax() + 1),
        1, cb_sayTime);
    timers.cancel(cb_playFragment);
    timers.create(
        random(AudioPolicy::effectiveFragmentMin(),
               AudioPolicy::effectiveFragmentMax() + 1),
        1, cb_playFragment);
}

void cb_clearWebAudio() {
    AudioPolicy::clearWebSpeakRange();
    AudioPolicy::clearWebFragmentRange();
    AudioPolicy::setWebSilence(false);
    setVolumeWebMultiplier(1.0f);           // ‚Üê NEW: reset volume to default
    webExpiryMs = Globals::defaultWebExpiryMs;  // reset stored duration

    // Reschedule with Globals defaults ‚Äî external arming ‚Üí cancel + create
    timers.cancel(cb_sayTime);
    timers.create(
        random(Globals::minSaytimeIntervalMs,
               Globals::maxSaytimeIntervalMs + 1),
        1, cb_sayTime);
    timers.cancel(cb_playFragment);
    timers.create(
        random(Globals::minAudioIntervalMs,
               Globals::maxAudioIntervalMs + 1),
        1, cb_playFragment);

    // Trigger SSE push so WebGUI sliders snap back to defaults
    WebGuiStatus::setAudioLevel(0.0f);  // triggers volume SSE
    // interval SSE fields will read cleared policy state
}

// Public request (called from AudioRoutes handler)
void RunManager::requestSetAudioIntervals(
    uint32_t speakMinMs, uint32_t speakMaxMs, bool hasSpeakRange,
    uint32_t fragMinMs,  uint32_t fragMaxMs,  bool hasFragRange,
    bool silence, uint32_t durationMs)
{
    pendingIntervals = {speakMinMs, speakMaxMs, fragMinMs, fragMaxMs,
                        durationMs, silence, hasSpeakRange, hasFragRange};
    // External arming from request ‚Üí cancel + create
    timers.cancel(cb_applyAudioIntervals);
    timers.create(1, 1, cb_applyAudioIntervals);
}


// Existing requestSetAudioLevel ‚Äî ADD expiry timer arming
void RunManager::requestSetAudioLevel(float webMultiplier) {
    audio.setVolumeWebMultiplier(webMultiplier);   // existing
    // NEW: arm/reset shared expiry ‚Äî any web audio change resets countdown
    timers.cancel(cb_clearWebAudio);
    timers.create(webExpiryMs, 1, cb_clearWebAudio);
}

// NEW: silence request (called from AudioRoutes silence endpoint)
void RunManager::requestSetSilence(bool active) {
    AudioPolicy::setWebSilence(active);
    if (active) {
        PlayAudioFragment::stop(0);
        PlaySentence::stop();
    }
    // Arm/reset shared expiry
    timers.cancel(cb_clearWebAudio);
    timers.create(webExpiryMs, 1, cb_clearWebAudio);
}


--- RunManager.cpp (existing cb_ changes) ---

// cb_sayTime ‚Äî replace Globals:: with AudioPolicy::effective*()
void cb_sayTime() {
    TimeStyle style = (random(0, 4) < 3) ? TimeStyle::INFORMAL
                      : static_cast<TimeStyle>(random(0, 2));
    RunManager::requestSayTime(style);
    timers.restart(
        random(AudioPolicy::effectiveSpeakMin(),
               AudioPolicy::effectiveSpeakMax() + 1),
        1, cb_sayTime);
}

// cb_playFragment ‚Äî replace Globals:: with AudioPolicy::effective*()
void cb_playFragment() {
    RunManager::requestPlayFragment();
    uint32_t lo = AudioPolicy::effectiveFragmentMin();
    uint32_t hi = AudioPolicy::effectiveFragmentMax();
    // Single-dir web theme gets tighter intervals
    // but explicit web range wins (user-requested)
    if (!AudioPolicy::isWebFragmentRangeActive()
        && AudioPolicy::themeBoxId().startsWith("web-")) {
        lo = Globals::singleDirMinIntervalMs;
        hi = Globals::singleDirMaxIntervalMs;
    }
    timers.restart(random(lo, hi + 1), 1, cb_playFragment);
}


--- AudioRoutes.cpp (Web layer, memory only) ---

void routeSetIntervals(AsyncWebServerRequest *request) {
    // Parse query params
    uint32_t speakMinMs = 0, speakMaxMs = 0;
    uint32_t fragMinMs = 0, fragMaxMs = 0;
    uint32_t durationMs = Globals::defaultWebExpiryMs;  // 13 hours
    bool silence = false;
    bool hasSpeakRange = false;
    bool hasFragRange = false;

    if (request->hasParam("speakMin") && request->hasParam("speakMax")) {
        speakMinMs = clamp(request->getParam("speakMin")->value().toInt(),
                           MINUTES(1), HOURS(4));
        speakMaxMs = clamp(request->getParam("speakMax")->value().toInt(),
                           MINUTES(1), HOURS(4));
        hasSpeakRange = true;
    }
    if (request->hasParam("fragMin") && request->hasParam("fragMax")) {
        fragMinMs = clamp(request->getParam("fragMin")->value().toInt(),
                          MINUTES(1), HOURS(2));
        fragMaxMs = clamp(request->getParam("fragMax")->value().toInt(),
                          MINUTES(1), HOURS(2));
        hasFragRange = true;
    }
    if (request->hasParam("silence"))
        silence = request->getParam("silence")->value() == "1";
    if (request->hasParam("dur"))
        durationMs = clamp(request->getParam("dur")->value().toInt(),
                           MINUTES(1), HOURS(12));

    RunManager::requestSetAudioIntervals(
        speakMinMs, speakMaxMs, hasSpeakRange,
        fragMinMs, fragMaxMs, hasFragRange,
        silence, durationMs);

    request->send(200, "text/plain", "OK");
}

// In attachRoutes:
server.on("/api/audio/intervals", HTTP_GET,  routeSetIntervals);
server.on("/api/audio/intervals", HTTP_POST, routeSetIntervals);

void routeSetSilence(AsyncWebServerRequest *request) {
    bool active = request->hasParam("active")
                  && request->getParam("active")->value() == "1";
    RunManager::requestSetSilence(active);
    request->send(200, "text/plain", "OK");
}

server.on("/api/audio/silence", HTTP_GET,  routeSetSilence);
server.on("/api/audio/silence", HTTP_POST, routeSetSilence);


===========================================================
WEBGUI PLAN
===========================================================

PLACEMENT
  All controls inside the existing Audio <section class="panel">.
  No separate panel, no modal, no dev menu ‚Äî this is user-facing.
  <hr> below audio panel to visually separate audio from light panel.

LAYOUT (index.html)
  Audio panel:
    [üîä] [Audio]  [dir/file] [‚è≠]  ...  [üëé score üëç]    ‚Üê üîä toggle added left
    Volume         [====slider====] 100%                   ‚Üê existing
    Tijdspraak     [====slider====] 30m                    ‚Üê NEW
    Audio-interval [====slider====] 15m                    ‚Üê NEW
    Geldig         [====slider====] 1u                     ‚Üê NEW
  <hr>

  Labels are Dutch (user-facing). Slider value labels show human-readable
  time: 5m, 10m, 15m, 30m, 45m, 1u, 1u30, 2u, 3u, 4u.

CONTROLS
  üîä/üîá Silence toggle
    - Button in audio-header-row, leftmost position (before Audio label)
    - üîä = normal (audio active), üîá = muted (silence active)
    - Instant send on click ‚Äî no debounce
    - fetch('/api/audio/silence?active=0|1', {method:'POST'})

  Tijdspraak slider (speak interval)
    - Range: 1 min ‚Äì 12 hr, non-linear/logarithmic steps
    - Steps: [1,2,3,5,10,15,20,30,45,60,90,120,180,240,360,480,720]
    - Slider maps position 0-16 ‚Üí step value
    - Debounce 3 sec after last slide ‚Üí auto-send
    - Firmware expands single value to ¬±30% range (min=val*0.7, max=val*1.3)

  Audio-interval slider (fragment interval)
    - Range: 2 min ‚Äì 12 hr, non-linear/logarithmic steps
    - Steps: [2,3,5,10,15,20,30,45,60,90,120,180,240,360,480,720]
    - Same debounce pattern as tijdspraak

  Geldig slider (duration / validity)
    - Range: 5 min ‚Äì 13 hr, non-linear/logarithmic steps
    - Steps: [5,10,15,30,45,60,120,240,360,480,720,780] (minutes)
    - Same debounce pattern
    - Default position: 780m (13u) ‚Äî matches Globals::defaultWebExpiryMs
    - Applies to ALL web audio settings: volume, intervals, AND silence

  Visual feedback: after debounce fires and fetch succeeds,
  briefly flash the value label green ("‚úì") for 1 second.

INTERACTION
  No Apply button, no Reset button.
  Each slider auto-sends after 3 sec debounce.
  All three interval values sent together in one fetch
  (collect current slider positions on debounce fire).

  Reset = slide back to default position. Slider at default = no web change.
  Firmware detects "default" value and clears the web setting.

  Silence toggle is independent ‚Äî instant, separate endpoint.

HTML CHANGES (index.html)
  Before:
    <div class="row audio-header-row">
      <h2 id="audio-box-label" ...>Audio</h2>
      ...
    </div>
  After:
    <div class="row audio-header-row">
      <button id="audio-mute" class="btn-icon">üîä</button>
      <h2 id="audio-box-label" ...>Audio</h2>
      ...
    </div>

  After the Volume row, add:
    <div class="row">
      <label>Tijdspraak</label>
      <input type="range" id="speak-interval" min="0" max="16" value="9">
      <span id="speak-num">60m</span>
    </div>
    <div class="row">
      <label>Audio-interval</label>
      <input type="range" id="frag-interval" min="0" max="15" value="7">
      <span id="frag-num">30m</span>
    </div>
    <div class="row">
      <label>Geldig</label>
      <input type="range" id="interval-duration" min="0" max="11" value="11">
      <span id="dur-num">13u</span>
    </div>

  After </section> (audio panel close), add:
    <hr class="panel-sep">

CSS CHANGES (styles.css)
  .panel-sep { border: none; border-top: 1px solid #3a3a5a; margin: 0.2rem 0; }
  #audio-mute { font-size: 1.1rem; }
  #audio-mute.muted { opacity: 0.5; }

JS PSEUDOCODE (audio.js additions)

  // Non-linear step tables (logarithmic distribution)
  var speakSteps = [1,2,3,5,10,15,20,30,45,60,90,120,180,240,360,480,720];
  var fragSteps  = [2,3,5,10,15,20,30,45,60,90,120,180,240,360,480,720];
  var durSteps   = [5,10,15,30,45,60,120,240,360,480,720,780];

  var debounceTimer = null;
  var muteBtn, speakSlider, fragSlider, durSlider;
  var speakLabel, fragLabel, durLabel;

  function formatMinutes(min) {
    if (min < 60) return min + 'm';
    var h = Math.floor(min / 60);
    var m = min % 60;
    return m === 0 ? h + 'u' : h + 'u' + m;
  }

  function initIntervalControls() {
    muteBtn = document.getElementById('audio-mute');
    speakSlider = document.getElementById('speak-interval');
    fragSlider = document.getElementById('frag-interval');
    durSlider = document.getElementById('interval-duration');
    speakLabel = document.getElementById('speak-num');
    fragLabel = document.getElementById('frag-num');
    durLabel = document.getElementById('dur-num');

    // Silence toggle ‚Äî instant
    if (muteBtn) {
      muteBtn.onclick = function() {
        var isMuted = muteBtn.classList.toggle('muted');
        muteBtn.textContent = isMuted ? 'üîá' : 'üîä';
        fetch('/api/audio/silence?active=' + (isMuted ? '1' : '0'),
              {method:'POST'}).catch(function(){});
      };
    }

    // Slider oninput ‚Äî update label immediately
    function bindSlider(slider, steps, label) {
      if (!slider || !label) return;
      slider.oninput = function() {
        var val = steps[parseInt(slider.value, 10)];
        label.textContent = formatMinutes(val);
        scheduleIntervalSend();
      };
    }
    bindSlider(speakSlider, speakSteps, speakLabel);
    bindSlider(fragSlider, fragSteps, fragLabel);
    bindSlider(durSlider, durSteps, durLabel);
  }

  function scheduleIntervalSend() {
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(sendIntervals, 3000);
  }

  function sendIntervals() {
    var speakMin = speakSteps[parseInt(speakSlider.value, 10)];
    var fragMin  = fragSteps[parseInt(fragSlider.value, 10)];
    var durMin   = durSteps[parseInt(durSlider.value, 10)];
    var url = '/api/audio/intervals'
      + '?speak=' + speakMin
      + '&frag=' + fragMin
      + '&dur=' + durMin;
    fetch(url, {method:'POST'})
      .then(function() { flashConfirm(); })
      .catch(function(){});
  }

  function flashConfirm() {
    // briefly show ‚úì on all labels
    [speakLabel, fragLabel, durLabel].forEach(function(el) {
      if (!el) return;
      var orig = el.textContent;
      el.textContent = '‚úì';
      el.style.color = '#4f4';
      setTimeout(function() {
        el.textContent = orig;
        el.style.color = '';
      }, 1000);
    });
  }

  // SSE: update slider positions on state event
  function updateIntervalsFromState(data) {
    // data.speakMin, data.fragMin, data.durMin, data.silence
    if (typeof data.silence === 'boolean' && muteBtn) {
      muteBtn.textContent = data.silence ? 'üîá' : 'üîä';
      muteBtn.classList.toggle('muted', data.silence);
    }
    // Map value back to slider step index
    function findStep(steps, val) {
      for (var i = steps.length - 1; i >= 0; i--) {
        if (steps[i] <= val) return i;
      }
      return 0;
    }
    if (typeof data.speakMin === 'number' && speakSlider && speakLabel) {
      speakSlider.value = findStep(speakSteps, data.speakMin);
      speakLabel.textContent = formatMinutes(data.speakMin);
    }
    if (typeof data.fragMin === 'number' && fragSlider && fragLabel) {
      fragSlider.value = findStep(fragSteps, data.fragMin);
      fragLabel.textContent = formatMinutes(data.fragMin);
    }
    if (typeof data.durMin === 'number' && durSlider && durLabel) {
      durSlider.value = findStep(durSteps, data.durMin);
      durLabel.textContent = formatMinutes(data.durMin);
    }
  }

  // Call initIntervalControls() from existing init() function.
  // Expose updateIntervalsFromState in return object for SSE.

SSE EXTENSION
  Add silence + interval fields to the existing 'state' SSE event:
    { ...existing fields..., silence: bool, speakMin: number,
      fragMin: number, durMin: number }
  Handled by Kwal.audio.updateIntervalsFromState(data) in
  the existing onState callback chain.

API NOTE ‚Äî SIMPLIFICATION
  Because sliders send a single center value (not min+max pair),
  the firmware route and RunManager request can be simplified:
  - Route receives: speak (center min), frag (center min), dur (min)
  - Firmware calculates: speakMin = val*0.7, speakMax = val*1.3
  - This eliminates hasSpeakRange/hasFragRange booleans
  - Active = slider value differs from Globals default
  - Silence is a separate route (/api/audio/silence) ‚Äî instant, no debounce

UNIFIED EXPIRY NOTE
  All three web audio routes share one expiry timer (cb_clearWebAudio):
    1. /api/audio/intervals  ‚Äî arms/resets with explicit dur param
    2. /api/audio/level      ‚Äî arms/resets with stored webExpiryMs
    3. /api/audio/silence    ‚Äî arms/resets with stored webExpiryMs
  When ANY fires, the expiry countdown resets.
  On expiry: webMultiplier ‚Üí 1.0, intervals ‚Üí Globals defaults, silence ‚Üí off.
  Volume slider JS does NOT need to send Geldig duration ‚Äî firmware uses stored value.

===========================================================
TIMER SLOT BUDGET
===========================================================
  New timer slots needed:
    1  cb_applyAudioIntervals    ‚Äî one-shot, immediate, auto-freed
    1  cb_clearWebAudio          ‚Äî one-shot, auto-freed after Geldig duration
  Total: 2 transient slots (never concurrent with each other in steady state)
  Current pool: 40 slots. Impact: negligible.
  Note: shared expiry timer is armed by volume, intervals, AND silence routes.

===========================================================
RISK ASSESSMENT
===========================================================
  Low:   No SD I/O, no network I/O, no blocking.
  Low:   No new permanent timers; 1 transient during web audio period.
  Low:   Policy changes are additive (existing gates get one more AND clause).
  Low:    Silence exempts *_FAIL health alerts ‚Äî they always speak through.
          Implementation: isHealthAlert(req) check in canSpeak().

===========================================================
OPEN QUESTIONS (for user)
===========================================================
  1. DECIDED: NO ‚Äî silence does NOT block health/error speech.
     *_FAIL requests (SD_FAIL, WIFI_FAIL, etc.) always speak through.
  2. DECIDED: 1 min ‚Äì 12 hr (non-linear/logarithmic steps)
  3. DECIDED: 2 min ‚Äì 12 hr (non-linear/logarithmic steps)
  4. DECIDED: YES ‚Äî also affects cb_sayRTCtemperature (same pattern).
  5. DECIDED: Fold into existing audio panel. <hr> below to separate from light.
  6. DECIDED: Unified expiry ‚Äî volume slider, interval sliders, and silence
     toggle all share one "Geldig" timer. Default 13 hr (Globals.h).
     Any web audio change resets the countdown. On expiry: volume ‚Üí 1.0,
     intervals ‚Üí Globals defaults, silence ‚Üí off.

===========================================================
IMPLEMENTATION ORDER
===========================================================
  1. AudioPolicy: add web interval/silence state (8 functions)
  2. AlertState + SpeakPolicy: add isWebSilenceActive() gate
  3. RunManager: add requestSetAudioIntervals + cb_apply/cb_clearWebAudio
  4. RunManager: refactor cb_sayTime + cb_playFragment + cb_sayRTCtemperature
     to use effective*()
  4b. RunManager: extend requestSetAudioLevel to arm shared expiry timer
  4c. RunManager: add requestSetSilence + arm shared expiry timer
  5. AudioRoutes: add /api/audio/intervals + /api/audio/silence routes
  6. WebGUI JS: build control panel + fetch logic
  7. SSE: extend pushState with web audio info
  8. Test on HOUT

===========================================================
